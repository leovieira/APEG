apeg Fortress;


//-------------------------------------------------------------------------
//  Components and APIs
//-------------------------------------------------------------------------
/*
file:
   compilation_unit w
 / (w imports)? w exports (w decls)? w
 / (w imports)? w abs_decls w
 / w imports (w abs_decls)? w;

compilation_unit:
   w component w
 / w api;
 
component:
   'component' w dotted_id (w imports)? w exports (w decls)? w 'end';

api:
   'api' w dotted_id (w imports)? (w abs_decls)? w 'end';

imports:
   import (wr import)*;

import:
   'import' wr import_from
 / 'import' wr aliased_dotted_ids;

import_from:
   '*' (wr 'except' wr names)? wr 'from' wr dotted_id
 / aliased_names wr 'from' wr dotted_id;

names:
   name
 / '{' w name_list w '}';

name_list:
   name (w ',' w name)*;

aliased_names:
   aliased_name
 / '{' w aliased_name_list w '}';

aliased_name:
   'opr' w op (w 'as' w op)?
 / 'opr' w left_encloser w right_encloser (w 'as' w left_encloser w right_encloser)?
 / id (wr 'as' wr dotted_id)?;

aliased_name_list:
   aliased_name (w ',' w aliased_name)*;

aliased_dotted_ids:
   aliased_dotted_id
 / '{' w aliased_dotted_id_list w '}';

aliased_dotted_id:
   dotted_id (wr 'as' wr dotted_id)?;

aliased_dotted_id_list:
   aliased_dotted_id (w ',' w aliased_dotted_id)*;

exports:
   export (wr export)*;

export:
   'export' wr dotted_ids;

dotted_ids:
   dotted_id
 / '{' w dotted_id_list w '}';

dotted_id_list:
   dotted_id (w ',' w dotted_id)*;
*/
//-------------------------------------------------------------------------
//  Top-level Declarations
//-------------------------------------------------------------------------


//-------------------------------------------------------------------------
//  Types
//-------------------------------------------------------------------------

type:
   !'1' ('io' w)? type_primary (w 'in' w expr)?;

op_type:
   type_primary 
 / type_prefix;

type_primary:
   type_primary_front tight_infix_postfix
 / type_primary_front wr type_primary
 / type_primary_front wr loose_infix
 / type_primary_front;

type_prefix:
   dim_prefix_op type_primary
 / dim_prefix_op type_prefix
 / dim_prefix_op wr type_primary
 / dim_prefix_op wr type_prefix;

tight_infix_postfix:
   type_infix_op type_primary (w throws)?
 / type_infix_op type_prefix (w throws)?
 / dim_infix_op type_primary
 / dim_infix_op type_prefix
 / dim_postfix_op wr type_primary
 / dim_postfix_op wr type_prefix
 / dim_postfix_op;

loose_infix:
   type_infix_op wr type_primary (w throws)?
 / type_infix_op wr type_prefix (w throws)?
 / dim_infix_op wr type_primary
 / dim_infix_op wr type_prefix;

type_primary_front:
   type_front type_tail*;

type_front:
   parenthesized_type
 / domain
 / tuple_type
 / type_ref
 / void_type
 / '1';

parenthesized_type:
   '(' w type w ')';

domain:
   '(' w (type w ',' w)* (type w '...' w ',' w)? keyword_type (w ',' w keyword_type)* w ')'
 / '(' w (type w ',' w)* type w '...' w ')';

keyword_type:
   bind_id w '=' w type;

tuple_type:
   '(' w type w ',' w type_list w ')';

type_list:
   type (w ',' w type)*;

type_ref:
   'Unity'
 / id static_args?;

void_type:
   '(' w ')';

type_tail:
   array_type_size
 / exponentiation
 / parenthesized_type_left
 / id_left;

array_type_size:
   '[' (w array_size)? w ']';

array_size:
   extent_range (w ',' w extent_range)*;

extent_range:
   (static_args w)? '#' (w static_args)?
 / (static_args w)? ':' (w static_args)?
 / static_args;

exponentiation:
   '^' int_expr
 / '^' '(' w extent_range (w 'BY' w extent_range)* w ')';

parenthesized_type_left:
   '(' w op_type w ')';

id_left:
   id;

type_infix_op:
   '->';

dim_infix_op:
   'DOT'
 / '/'
 / 'per';

dim_prefix_op:
   'square'
 / 'cubic'
 / 'inverse';

dim_postfix_op:
   'squared'
 / 'cubed';

trait_type:
   trait_type_front trait_type_tail+
 / type_ref;

trait_type_front:
   parenthesized_type
 / tuple_type
 / type_ref
 / void_type;

trait_type_tail:
   array_type_size_trait
 / exponentiation_trait;

array_type_size_trait:
   '[' (w array_size)? w ']';

exponentiation_trait:
   '^' int_expr
 / '^' '(' w extent_range (w 'BY' w extent_range)* w ')'; 

//-------------------------------------------------------------------------
//  Types without Newlines
//-------------------------------------------------------------------------
   
 
//-------------------------------------------------------------------------
//  Symbols and Operators
//-------------------------------------------------------------------------

encloser_pair:
   (left_encloser / encloser) (w '.' w)? (right_encloser / encloser);

bar:
   &('|' wr generator_clause_list closing_comprehension) '|';

closing_comprehension:       // In Rats! definiton, a right encloser is a closing comprehension too
   w '}'
 / w '|>'
 / br array_comprehension_clause
 / w ']';

sd:
   ('*' / '.')?;

bars:
   '|' (sd '|')*;

slashes:
   '/' (sd '/')*
 / '\\' (sd '\\')*;

lesses:
   '<' (sd '<')*;

greaters:
   '>' (sd '>')*;

encloser:
   !bar bars !('*' / '.' / '>' / '/' / '\\' / '->');

left_encloser:
   left_encloser_multi
 / !('|') .;

left_encloser_multi:
   '(.' ('/'+ / '\\'+)
 / '[/\\/\\/'
 / '[/\\/'
 / '[' (sd slashes)
 / '{' (sd slashes)
 / lesses sd (slashes / bars)
 / bars sd slashes
 / '{*'
 / '[*'
 / '((.>'
 / '(.<';

right_encloser:
   right_encloser_multi
 / !('|') .;

right_encloser_multi:
   '/'+ '.)'
 / '\\'+ '.)'
 / slashes sd (greaters / bars / ']' / '}')
 / bars sd greaters
 / '*]'
 / '*}'
 / ']'
 / '}'
 / '>.)'
 / '<.))'
 / '/\\/\\/]'
 / '/\\/]';

exponent_op:
   '^T'
 / '^' (encloser / not_comp_op);

//----------------------------------------------------------------
// An operator name has at least two different uppercase letters
// also it does not begin and end with an underscore
//----------------------------------------------------------------
op_name:
   !('SUM' / 'PROD' / 'BY') head_op_name
 / keyword_operator;

head_op_name locals[String ch1, String ch2]:
   ch1=[A-Z] (
        '_'* ch2=[A-Z] !({?ch1 == ch2}) tail_op_name
      / '_'* &[A-Z] head_op_name
     );     

tail_op_name:
   !([A-Za-z0-9] / '_')       // there is no more symbols
 / ('_'* [A-Z])+ !([A-Za-z0-9] / '_');                                                         

op:
   cond_op
 / not_comp_op !'='
 / comp_op;

comp_op:
   '==='
 / '=/='
 / '<='
 / '>=';

cond_op:
   ':' (encloser / not_comp_op) ':' !not_comp_op
 / (encloser / not_comp_op) ':' !not_comp_op;

multi_op:
   '-/->'
 / '<-/-'
 / '-->'
 / '==>'
 / '>>>'
 / '|->'
 / '<<<'
 / '<->'
 / '<-'
 / '<=>'
 / '->'
 / double_right_arrow
 / '>>'
 / '<<'
 / '**'
 / '!!'
 / '::'
 / !right_encloser_multi '///'
 / !right_encloser_multi '//';

// The definition in Rats! uses a function the test if the character read is a valid operator
single_op:
   !(encloser / left_encloser / right_encloser / multi_op / comp_op / '=>') .;

not_comp_op:
   op_name
 / multi_op
 / single_op;

compound_op:
   not_comp_op '=';

/* The operator "=>" should not be in the left-hand sides of case/typecase expressions. */
double_right_arrow:
   '=>' &(w block_elems w '=>');

/* The operator "BY" should not be used with ExtentRange. */
cross_op:
   'BY' &(w extent_range);

less_than_equal:
   '<=' / 'LE';

less_than:
   '<' / 'LT';

greater_than_equal:
   '>=' / 'GE';

greater_than:
   '>' / 'GT';

implies:
   '->' / 'IMPLIES';

assign_op:
   ':='
 / compound_op;

accumulator:
   'SUM'
 / 'PROD'
 / 'BIG' w (encloser / op);

array_comprehension_clause:
   array_comprehension_left wr bar wr generator_clause_list;

//-------------------------------------------------------------------------
//  Identifiers
//-------------------------------------------------------------------------

id:
   !(keywords / op_name) (id_start id_rest+ / unicode_id_start) ;  // It can not be '_'

id_start:
   unicode_id_start / '_';

id_rest:
   '_' / '\'' / unicode_id_rest;

unicode_id_start:  // In the original rats file definition, this nonterminal allow the set of unicode characters
   [a-zA-Z];

unicode_id_rest:
   [a-zA-Z0-9];

bind_id:
   id / '_'; 

bind_id_list:
   bind_id (w ',' w bind_id)*;

bind_id_or_bind_tuple:
   bind_id
 / '(' w bind_id w ',' w bind_id_list w ')';

simple_name:
   id
 / 'opr' w op
 / 'opr' w encloser_pair;

api_name:
   qualified_name;

qualified_name:
   id &(w '...')                // it ignores the dots
 / id ('.' id)* &(w '...')       // it ignores the dots
 / id ('.' id)*;

//-------------------------------------------------------------------------
//  Keywords
//-------------------------------------------------------------------------

keywords:
   key !id_rest;

key:
   'absorbs'
 / 'abstract'
 / 'also'
 / 'api'
 / 'as'
 / 'asif'
 / 'at'
 / 'atomic'
 / 'bool'
 / 'case'
 / 'catch'
 / 'coerce'
 / 'coerces'
 / 'component'
 / 'comprises'
 / 'default'
 / 'dim'
 / 'do'
 / 'elif'
 / 'else'
 / 'end'
 / 'ensures'
 / 'except'
 / 'excludes'
 / 'exit'
 / 'export'
 / 'extends'
 / 'finally'
 / 'fn'
 / 'for'
 / 'forbid'
 / 'from'
 / 'getter'
 / 'hidden'
 / 'if'
 / 'import'
 / 'int'
 / 'invariant'
 / 'io'
 / 'juxtaposition'
 / 'label'
 / 'most'
 / 'nat'
 / 'native'
 / 'object'
 / 'of'
 / 'opr'
 / 'or'
 / 'override'
 / 'private'
 / 'property'
 / 'provided'
 / 'requires'
 / 'self'
 / 'settable'
 / 'setter'
 / 'spawn'
 / 'syntax'
 / 'test'
 / 'then'
 / 'throw'
 / 'throws'
 / 'trait'
 / 'transient'
 / 'try'
 / 'tryatomic'
 / 'type'
 / 'typecase'
 / 'unit'
 / 'value'
 / 'var'
 / 'where'
 / 'while'
 / 'widens'
 / 'with'
 / 'wrapped'
 / 'goto'
 / 'idiom'
 / 'public'
 / 'pure'
 / 'reciprocal'
 / 'static';

keyword_operator:
   'juxtaposition'
 / 'in'
 / 'per'
 / 'square'
 / 'cubic'
 / 'inverse'
 / 'squared'
 / 'cubed';

// BIG, FORALL, SI_unit

//-------------------------------------------------------------------------
//  Spaces and Comments
//-------------------------------------------------------------------------

end_of_file:
   !.;

white_space:
   space / new_line;

space:
   ' '
 / '\f'
 / no_new_line_comment;

new_line:
   '\r\n'
 / '\r'
 / '\n'
 / comment;

no_new_line_comment:
   '(*' no_new_line_comment_content* '*)';

no_new_line_comment_content:
   no_new_line_comment
 / '*' !')'
 / !'*' !new_line .;

comment:                        // it comment may have new lines.
   '(*' comment_content* '*)';

comment_content:
   comment 
 / '*' !')'
 / !'*' .; 

w:
   white_space*;
  
wr:
   white_space+;

s:
   space*;
   
sr:
   space+;

nl:
   s new_line w;

br:
   nl / s ';' w;

rect_separator:
   (w ';')+ w
 / sr
 / nl; 

 //-------------------------------------------------------------------------
//  TODO
//-------------------------------------------------------------------------

int_expr:
   int_literal;

int_literal:
   '0' / [1-9] [0-9]*;

throws:
   'throws' w '{' w '}';

block_elems:
   TODO;

generator_clause_list:
   TODO;

mapsto:
   mapsto_op;

mapsto_op:
   '|->';

no_new_line_expr:
   TODO;

array_comprehension_left:
   TODO;

decls:
   TODO;

abs_decls:
   'trait' w id w 'end';

expr:
   TODO;

static_args:
   TODO;

TODO:
   'TODO';
