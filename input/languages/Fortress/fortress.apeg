apeg Fortress;


//-------------------------------------------------------------------------
//  Components and APIs
//-------------------------------------------------------------------------
/*
file:
   compilation_unit w
 / (w imports)? w exports (w decls)? w
 / (w imports)? w abs_decls w
 / w imports (w abs_decls)? w;

compilation_unit:
   w component w
 / w api;
 
component:
   'component' w dotted_id (w imports)? w exports (w decls)? w 'end';

api:
   'api' w dotted_id (w imports)? (w abs_decls)? w 'end';

imports:
   import (wr import)*;

import:
   'import' wr import_from
 / 'import' wr aliased_dotted_ids;

import_from:
   '*' (wr 'except' wr names)? wr 'from' wr dotted_id
 / aliased_names wr 'from' wr dotted_id;

names:
   name
 / '{' w name_list w '}';

name_list:
   name (w ',' w name)*;

aliased_names:
   aliased_name
 / '{' w aliased_name_list w '}';

aliased_name:
   'opr' w op (w 'as' w op)?
 / 'opr' w left_encloser w right_encloser (w 'as' w left_encloser w right_encloser)?
 / id (wr 'as' wr dotted_id)?;

aliased_name_list:
   aliased_name (w ',' w aliased_name)*;

aliased_dotted_ids:
   aliased_dotted_id
 / '{' w aliased_dotted_id_list w '}';

aliased_dotted_id:
   dotted_id (wr 'as' wr dotted_id)?;

aliased_dotted_id_list:
   aliased_dotted_id (w ',' w aliased_dotted_id)*;

exports:
   export (wr export)*;

export:
   'export' wr dotted_ids;

dotted_ids:
   dotted_id
 / '{' w dotted_id_list w '}';

dotted_id_list:
   dotted_id (w ',' w dotted_id)*;
*/
//-------------------------------------------------------------------------
//  Top-level Declarations
//-------------------------------------------------------------------------

//-------------------------------------------------------------------------
//  Expressions
//-------------------------------------------------------------------------

expr:
   expr_front expr_tail*;

expr_front:
   assign_expr
 / op_expr
 / delimited_expr
 / flow_expr
 / 'fn' w bind_id (w throws)? w '=>' w expr
 / 'fn' w '(' (w params)? w ')' (w is_type)? (w throws)? w '=>' w expr;

expr_tail:
   w 'typed' w type
 / w 'asif' w type;

assign_expr:
   assign_lefts w assign_op w expr;

assign_lefts:
   '(' w assign_left (w ',' w assign_left)* w ')'
 / assign_left;

assign_left:
   primary_front assing_left_tail+
 / qualified_name;

assing_left_tail:
   subscript_assign
 / field_selection_assign;

subscript_assign:
   left_encloser (w static_args)? (w expr_list)? w right_encloser;

field_selection_assign:
   '.' id;

op_expr:
   op_expr_no_enc
 / op_expr_left_encloser
 / encloser;

op_expr_no_enc:
   op_expr_primary
 / op_expr_prefix
 / op;

tight_infix_right:
   encloser op_expr_primary
 / encloser op_expr_prefix
 / encloser wr op_expr_primary
 / encloser wr loose_infix_EXPR
 / encloser wr left_loose_infix
 / encloser;

left_loose_infix:
   op_expr_left_encloser
 / encloser wr op_expr_primary
 / encloser wr op_expr_prefix
 / encloser wr op_expr_left_encloser;

op_expr_left_encloser:
   encloser op_expr_no_enc;

op_expr_primary:
   primary tight_infix_postfix_EXPR
 / primary tight_infix_right
 / primary wr op_expr_primary
 / primary wr loose_infix_EXPR
 / primary wr left_loose_infix
 / primary;

op_expr_prefix:
   op op_expr_primary
 / op op_expr_prefix
 / op op_expr_left_encloser
 / op wr op_expr_primary
 / op wr op_expr_prefix
 / op wr op_expr_left_encloser;

tight_infix_postfix_EXPR:
   op op_expr_primary
 / op op_expr_primary
 / op op_expr_left_encloser
 / op wr op_expr_primary
 / op wr op_expr_prefix
 / op wr op_expr_left_encloser
 / op;

loose_infix_EXPR:
   op wr op_expr_primary
 / op wr op_expr_prefix
 / op wr op_expr_left_encloser;

primary:
   primary_item (w ',' w primary_item)*;

primary_item:
   left_associated_primary
 / math_primary;

left_associated_primary:
   dotted_id_chain w static_args parenthesis_delimited parenthesis_delimited_left* selector*
 / dotted_id_chain subscripting_left+ parenthesis_delimited_left* selector*
 / dotted_id_chain parenthesis_delimited parenthesis_delimited_left* selector*
 / dotted_id_chain selector*
 / primary_front subscripting_left* parenthesis_delimited_left* selector+;

dotted_id_chain:
   id ('.' w id)+;

math_primary:
   primary_front math_item*;

primary_front:
   array_expr
 / map_expr
 / comprehension
 / left_encloser (w static_args)? (w expr_list)? w right_encloser
 / parenthesis_delimited
 / literal_expr
 / var_or_fn_ref
 / 'self';

var_or_fn_ref:
   id (w static_args)?;

subscripting_left:
   '{' (w static_args)? (w expr_list)? w '}'
 / '[' (w static_args)? (w expr_list)? w ']'
 / left_encloser (w static_args)? (w expr_list)? w right_encloser;

parenthesis_delimited_left:
   parenthesis_delimited;

parenthesis_delimited:
   parenthesized
 / arg_expr
 / '(' w ')';

selector:
   method_invocation_selector
 / field_selection_selector;

method_invocation_selector:
   '.' w id (w static_args)? parenthesis_delimited parenthesis_delimited_left*;

field_selection_selector:
   '.' w id subscripting_left* parenthesis_delimited_left*;

math_item:
   subscripting
 / exponentiation_EXPR
 / parenthesis_delimited
 / literal_expr
 / var_or_fn_ref
 / 'self';

// There are two different definitions od exponentiation in specification and in Rats! files
exponentiation_EXPR:
   '^' exponent
 / exponent_op;

exponent:
   parenthesis_delimited
 / literal_expr
 / id
 / 'self';

flow_expr:
   'exit' (w id)? (w 'with' w expr)?
 / accumulator (w static_args)? (w '[' generator_clause_list w ']')? w expr
 / 'BIG' left_encloser w '|->' (w static_args)? w right_encloser w expr
 / 'BIG' left_encloser w (w static_args)? w right_encloser w expr
 / 'atomic' w atomic_back
 / 'tryatomic' w atomic_back
 / 'spawn' w expr
 / 'throw' w expr;

atomic_back:
   assign_expr
 / op_expr
 / delimited_expr;

generator_clause_list:
   generator_binding (w ',' w generator_clause)*;

generator_binding:
   bind_id_or_bind_tuple w '<-' w expr;

generator_clause:
   generator_binding
 / expr; 

subscripting:
   '[' (w static_args)? (w expr_list)? w ']'
 / '{' (w static_args)? (w expr_list)? w '}'
 / left_encloser (w static_args)? (w expr_list)? w right_encloser;

//-------------------------------------------------------------------------
//  Expressions Enclosed by Keywords or Symbols
//-------------------------------------------------------------------------

delimited_expr locals[String n1, String n2]:
   arg_expr
 / parenthesized
 / 'object' (w extends_where)? (nl go_in_an_object)? w 'end'
 / do
 / 'label' w n1=id w block_elems w 'end' w n2=id {? n1 == n2}
 / 'while' w generator_clause w do
 / 'for' w generator_clause_list w do_front w 'end'
 / 'if' w generator_clause w 'then' w block_elems (w elifs)? (w else)? w 'end'
 / '(' w 'if' w generator_clause w 'then' w block_elems (w elifs)? w else (w 'end')? w ')'
 / 'case' w expr (w (encloser / op))? w 'of' w case_clauses (br case_else)? w 'end'
 / 'case' w 'most' (encloser / op) w 'of' w case_clauses w 'end'
 / 'typecase' w expr w 'of' w type_case_clauses (br case_else)? w 'end'
 / 'try' w block_elems (w catch)? (w 'forbid' w trait_types)? (w 'finally' w block_elems)? w 'end';

do:
   (do_front w 'also' w)* do_front w 'end';

do_front:
   ('at' w expr w)? ('atomic' w)? 'do' (w block_elems)?;

arg_expr:
   '(' w (expr w ',' w)* (expr w '...' w ',' w)? keyword_expr (w ',' w keyword_expr)* w ')'
 / '(' w (expr w ',' w)* expr w '...' w ')'
 / tuple_expr;

tuple_expr:
   '(' w (expr w ',' w)+ expr w ')';

keyword_expr:
   bind_id w '=' w expr;

parenthesized:
   '(' w expr w ')';

elifs:
   elif(w elif)*;

elif:
   'elif' w generator_clause w 'then' w block_elems;

else:
   'else' w block_elems;

case_clauses:
   case_clause (br case_clause)*;

case_else:
   'else' w '=>' w block_elems;

type_case_clauses:
   type_case_clause (br type_case_clause)*;

type_case_clause:
   id w '=>' w block_elems
 / (id w ':' w)? type_or_pattern w '=>' w block_elems;

catch:
   'catch' w bind_id w catch_clauses;

catch_clauses:
   catch_clause (br catch_clause)*;

catch_clause:
   trait_type w '=>' w block_elems;

map_expr:
   left_encloser (w static_args)? w entry_list w right_encloser;

comprehension:
   ('BIG' w)? '[' (w static_args)? w array_comprehension_clause (br array_comprehension_clause)* w 	']'
 / ('BIG' w)? left_encloser (w static_args)? w entry wr '|' wr generator_clause_list w right_encloser
 / ('BIG' w)? left_encloser (w static_args)? w expr wr '|' wr generator_clause_list w right_encloser;

/****
 The operator "|->" should not be in the left-hand sides of map expressions
 and map/array comprehensions.
****/
mapsto_op:
   '|->' !(w expr (w '|->' / wr '|' / w '}' / w ','));

/****
 The operator "<-" should not be in the left-hand sides of
 generator clause lists.
*****/
left_arrow_op:
   '<-' !(w expr (w '<-' / w ','));

entry:
   expr w '|->' w expr;

array_comprehension_left:
   id_or_int w '|->' w expr
 / '(' w id_or_int w ',' w id_or_int_list w ')' w '|->' w expr;

id_or_int:
   id
 / int_literal_expr;

id_or_int_list:
   id_or_int (w ',' w id_or_int)*;

expr_list:
   expr (w ',' w expr)*;

entry_list:
   entry (w ',' w entry)*;

//-------------------------------------------------------------------------
//  Expressions without Newlines
//-------------------------------------------------------------------------

no_new_line_expr:
   no_new_line_expr_front no_new_line_expr_tail*;

no_new_line_expr_front:
   no_new_line_assign_expr
 / no_new_line_op_expr
 / delimited_expr
 / no_new_line_flow_expr
 / 'fn' w bind_id (w throws)? w '=>' w no_new_line_expr
 / 'fn' w '(' (w params)? w ')' (w is_type)? (w throws)? w '=>' w no_new_line_expr;

no_new_line_expr_tail:
   s 'typed' w no_new_line_type
 / s 'asif' w no_new_line_type;

no_new_line_assign_expr:
   assign_lefts s assign_op w no_new_line_expr;

no_new_line_op_expr:
   no_new_line_op_expr_no_enc
 / no_new_line_op_expr_left_encloser
 / encloser;

no_new_line_op_expr_no_enc:
   no_new_line_op_expr_primary
 / no_new_line_op_expr_prefix
 / op;

no_new_line_tight_infix_right:
   encloser no_new_line_op_expr_primary
 / encloser no_new_line_op_expr_prefix
 / encloser sr no_new_line_op_expr_primary
 / encloser sr no_new_line_loose_infix_EXPR
 / encloser sr no_new_line_left_loose_infix
 / encloser;

no_new_line_left_loose_infix:
   no_new_line_op_expr_left_encloser
 / encloser sr no_new_line_op_expr_primary
 / encloser sr no_new_line_op_expr_prefix
 / encloser sr no_new_line_op_expr_left_encloser;

no_new_line_op_expr_left_encloser:
   encloser no_new_line_op_expr_no_enc;

no_new_line_op_expr_primary:
   primary no_new_line_tight_infix_postfix_EXPR
 / primary no_new_line_tight_infix_right
 / primary sr no_new_line_op_expr_primary
 / primary sr no_new_line_loose_infix_EXPR
 / primary sr no_new_line_left_loose_infix
 / primary;

no_new_line_op_expr_prefix:
   op no_new_line_op_expr_primary
 / op no_new_line_op_expr_prefix
 / op no_new_line_op_expr_left_encloser
 / op sr no_new_line_op_expr_primary
 / op sr no_new_line_op_expr_prefix
 / op sr no_new_line_op_expr_left_encloser;

no_new_line_tight_infix_postfix_EXPR:
   op no_new_line_op_expr_primary
 / op no_new_line_op_expr_primary
 / op no_new_line_op_expr_left_encloser
 / op sr no_new_line_op_expr_primary
 / op sr no_new_line_op_expr_prefix
 / op sr no_new_line_op_expr_left_encloser
 / op;

no_new_line_loose_infix_EXPR:
   op wr no_new_line_op_expr_primary
 / op wr no_new_line_op_expr_prefix
 / op sr no_new_line_op_expr_left_encloser;

no_new_line_generator_binding:
   bind_id_or_bind_tuple w '<-' w no_new_line_expr;

no_new_line_generator_clause:
   no_new_line_generator_binding
 / no_new_line_expr; 

no_new_line_flow_expr:
   'exit' (w id)? (w 'with' w no_new_line_expr)?
 / accumulator (w static_args)? (w '[' generator_clause_list w ']')? w no_new_line_expr
 / 'BIG' left_encloser w '|->' (w static_args)? w right_encloser w no_new_line_expr
 / 'BIG' left_encloser w (w static_args)? w right_encloser w no_new_line_expr
 / 'atomic' w no_new_line_atomic_back
 / 'tryatomic' w no_new_line_atomic_back
 / 'spawn' w no_new_line_expr
 / 'throw' w no_new_line_expr;

no_new_line_atomic_back:
   assign_expr
 / no_new_line_op_expr
 / delimited_expr;

no_new_line_generator_clause_list:
   generator_binding (s ',' w no_new_line_generator_clause)*;

no_new_line_var_w_types:
   no_new_line_var_w_type
 / '(' w no_new_line_var_w_type (w ',' w no_new_line_var_w_type)+ w ')';

no_new_line_var_w_type:
   bind_id s no_new_line_is_type;

no_new_line_is_type:
   ':' w no_new_line_type;

no_new_line_is_type_or_none:
   ':' w no_new_line_type_or_none;

no_new_line_type_or_none:
   no_new_line_type
 / 'None';

//-------------------------------------------------------------------------
//  Local Declarations
//-------------------------------------------------------------------------

block_elems:
   block_elem br block_elems
 / block_elem w ';' &(w 'elif' / w 'also' / w 'end' / w 'catch' / w 'forbid' / w 'finally' / w ')')
 / block_elem &(w 'elif' / w 'also' / w 'end' / w 'catch' / w 'forbid' / w 'finally' / w ')')
 / block_elem &(w else / br case_clause / br (id w ':' w)? type_or_pattern / br case_else)
 / block_elem w ';' &(w else);

block_elem:
   local_var_fn_decl
 / no_new_line_expr (s ',' w no_new_line_generator_clause_list)?;

local_var_fn_decl:
   local_fn_decl (br local_fn_decl)*
 / local_var_decl;

local_fn_decl:
   mods? id (w static_params)? w val_param fn_header_clause w '=' no_new_line_expr;

val_param:
   '(' (w params)? w ')'
 / bind_id;

params:
   (param w ',' w)* (var_args w ',' w)? keyword (w ',' w keyword)*
 / (param w ',' w)* var_args
 / param (w ',' w param)*;

param:
   bind_id s ':' s pattern
 / bind_id s ':' s no_new_line_pattern
 / bind_id; 

var_args:
   bind_id s ':' s no_new_line_type '...';

keyword:
   param s '=' w no_new_line_expr;

local_var_decl:
   ('var' w)? var_may_types s '=' w no_new_line_expr
 / ('var' w)? no_new_line_var_w_type_or_pattern s ':=' w no_new_line_expr
 / ('var' w)? no_new_line_var_w_types
 / var_wo_types s '=' w no_new_line_expr
 / ('var' w)? var_wo_types s ':' s no_new_line_type s '...' (s init_val)? 
 / ('var' w)? var_wo_types s ':' s tuple_type s '...' (s init_val)?;

var_may_types:
   var_may_type
 / '(' w var_may_type (w ',' w var_may_type)+ w ')';

var_may_type:
   bind_id (s ':' s (no_new_line_pattern / no_new_line_type))?;

var_wo_types:
   var_wo_type
 / '(' w var_wo_type (w ',' w var_wo_type)+ w ')';

var_wo_type:
   bind_id
 / unpasting;

no_new_line_var_w_type_or_patterns:
   no_new_line_var_w_type_or_pattern
 / '(' no_new_line_var_w_type_or_pattern (w ',' w no_new_line_var_w_type_or_pattern)+ w ')';

no_new_line_var_w_type_or_pattern:
   bind_id s no_new_line_is_type_or_pattern;

no_new_line_is_type_or_pattern:
   ':' s no_new_line_pattern
 / ':' s no_new_line_type;

unpasting:
   '[' w unpasting_elems w ']';

unpasting_elems:
   unpasting_elem (rect_separator unpasting_elem)*;

unpasting_elem:
   bind_id ('[' w unpasting_dim w ']')?
 / unpasting;

unpasting_dim:
   extent_range ( w 'BY' w extent_range)+;

case_clause:
   no_new_line_expr w '=>' w block_elems;

//-------------------------------------------------------------------------
//  Literals
//-------------------------------------------------------------------------

literal_expr:
   '(' w ')'
 / numeric_literal_expr
 / char_literal_expr
 / string_literal_expr;

/* This part is not in the Rats! specification
array_expr:
   '[' w rect_elements w ']';

rect_elements:
   no_space_expr multi_dim_cons*;

multi_dim_cons:
   rect_separator no_space_expr;
*/

escape_sequence:
   '\\' ('b' / 't' / 'n' / 'f' / 'r' / '"' / '\\');

numeric_literal_expr:    // there is some differences in Rats! specification about numeric_literal
   float_literal_expr
 / int_literal_expr;

float_literal_expr:
   digit_string '.' digit_string;

int_literal_expr:
   digit_string;

digit_string:
   [0-9]+;

char_literal_expr:
   '\'' char_literal_content '\'';

string_literal_expr:
   '\"' string_literal_content '\"';

string_literal_content:
   escape_sequence
 / !('\"' / '\\') .;

char_literal_content:
   escape_sequence
 / !'\'' .;

//-------------------------------------------------------------------------
//  Types
//-------------------------------------------------------------------------

type:
   !'1' ('io' w)? type_primary (w 'in' w expr)?;

op_type:
   type_primary 
 / type_prefix;

type_primary:
   type_primary_front tight_infix_postfix
 / type_primary_front wr type_primary
 / type_primary_front wr loose_infix
 / type_primary_front;

type_prefix:
   dim_prefix_op type_primary
 / dim_prefix_op type_prefix
 / dim_prefix_op wr type_primary
 / dim_prefix_op wr type_prefix;

tight_infix_postfix:
   '->' type_primary (w throws)?
 / '->' type_prefix (w throws)?
 / dim_infix_op type_primary
 / dim_infix_op type_prefix
 / dim_postfix_op wr type_primary
 / dim_postfix_op wr type_prefix
 / dim_postfix_op;

loose_infix:
   '->' wr type_primary (w throws)?
 / '->' wr type_prefix (w throws)?
 / dim_infix_op wr type_primary
 / dim_infix_op wr type_prefix;

type_infix_op:
   '->';

dim_infix_op:
   'DOT'
 / '/'
 / 'per';

type_primary_front:
   type_front type_tail*; // na definição não exige espaço. Achei estranho!

type_front:
   parenthesized_type
 / domain
 / tuple_type
 / type_ref
 / void_type
 / '1';

parenthesized_type:
   '(' w type w ')';

domain:
   '(' w (type w ',' w)* (type w '...' w ',' w)? keyword_type (w ',' w keyword_type)* w ')'
 / '(' w (type w ',' w)* type w '...' w ')';

keyword_type:
   bind_id w '=' w type;

tuple_type:
   '(' w type w ',' w type_list w ')';

type_list:
   type (w ',' w type)*;

type_ref:
   'Unity'
 / id static_args?;

void_type:
   '(' w ')';

type_tail:
   array_type_size
 / exponentiation
 / parenthesized_type_left
 / id_left;

array_type_size:
   '[' (w array_size)? w ']';

array_size:
   extent_range (w ',' w extent_range)*;

extent_range:
   (static_args w)? '#' (w static_args)?
 / (static_args w)? ':' (w static_args)?
 / static_args;

exponentiation:
   '^' int_expr
 / '^' '(' w extent_range (w 'BY' w extent_range)* w ')';

parenthesized_type_left:
   '(' w op_type w ')';

id_left:
   id;

dim_prefix_op:
   'square'
 / 'cubic'
 / 'inverse';

dim_postfix_op:
   'squared'
 / 'cubed';

trait_type:
   trait_type_front trait_type_tail+
 / type_ref;

trait_type_front:
   parenthesized_type
 / tuple_type
 / type_ref
 / void_type;

trait_type_tail:
   array_type_size_trait
 / exponentiation_trait;

array_type_size_trait:
   '[' (w array_size)? w ']';

exponentiation_trait:
   '^' int_expr
 / '^' '(' w extent_range (w 'BY' w extent_range)* w ')'; 

//-------------------------------------------------------------------------
//  Types without Newlines
//-------------------------------------------------------------------------

no_new_line_type:
   !'1' no_new_line_type_primary (w 'in' w no_new_line_expr)?;

no_new_line_type_primary:
   type_primary_front no_new_line_tight_infix_postfix
 / type_primary_front sr no_new_line_type_primary
 / type_primary_front sr no_new_line_loose_infix
 / type_primary_front;

no_new_line_type_prefix:
   dim_prefix_op no_new_line_type_primary
 / dim_prefix_op no_new_line_type_prefix
 / dim_prefix_op sr no_new_line_type_primary
 / dim_prefix_op sr no_new_line_type_prefix;

no_new_line_tight_infix_postfix:
   type_infix_op no_new_line_type_primary (s throws)?
 / type_infix_op no_new_line_type_prefix (s throws)?
 / dim_infix_op no_new_line_type_primary
 / dim_infix_op no_new_line_type_prefix
 / dim_postfix_op sr no_new_line_type_primary
 / dim_postfix_op sr no_new_line_type_prefix
 / dim_postfix_op;

no_new_line_loose_infix:
   type_infix_op sr no_new_line_type_primary (s throws)?
 / type_infix_op sr no_new_line_type_prefix (s throws)?
 / dim_infix_op sr no_new_line_type_primary
 / dim_infix_op sr no_new_line_type_prefix;

//-------------------------------------------------------------------------
//  Symbols and Operators
//-------------------------------------------------------------------------

encloser_pair:
   (left_encloser / encloser) (w '.' w)? (right_encloser / encloser);

bar:
   &('|' wr generator_clause_list closing_comprehension) '|';

closing_comprehension:       // In Rats! definiton, a right encloser is a closing comprehension too
   w '}'
 / w '|>'
 / br array_comprehension_clause
 / w ']';

sd:
   ('*' / '.')?;

bars:
   '|' (sd '|')*;

slashes:
   '/' (sd '/')*
 / '\\' (sd '\\')*;

lesses:
   '<' (sd '<')*;

greaters:
   '>' (sd '>')*;

encloser:
   !bar bars !('*' / '.' / '>' / '/' / '\\' / '->');

left_encloser:
   left_encloser_multi
 / !('|') .;

left_encloser_multi:
   '(.' ('/'+ / '\\'+)
 / '[/\\/\\/'
 / '[/\\/'
 / '[' (sd slashes)
 / '{' (sd slashes)
 / lesses sd (slashes / bars)
 / bars sd slashes
 / '{*'
 / '[*'
 / '((.>'
 / '(.<';

right_encloser:
   right_encloser_multi
 / !('|') .;

right_encloser_multi:
   '/'+ '.)'
 / '\\'+ '.)'
 / slashes sd (greaters / bars / ']' / '}')
 / bars sd greaters
 / '*]'
 / '*}'
 / ']'
 / '}'
 / '>.)'
 / '<.))'
 / '/\\/\\/]'
 / '/\\/]';

exponent_op:
   '^T'
 / '^' (encloser / not_comp_op);

//----------------------------------------------------------------
// An operator name has at least two different uppercase letters
// also it does not begin and end with an underscore
//----------------------------------------------------------------
op_name:
   !('SUM' / 'PROD' / 'BY') head_op_name
 / keyword_operator;

head_op_name locals[String ch1, String ch2]:
   ch1=[A-Z] (
        '_'* ch2=[A-Z] !({?ch1 == ch2}) tail_op_name
      / '_'* &[A-Z] head_op_name
     );     

tail_op_name:
   !([A-Za-z0-9] / '_')       // there is no more symbols
 / ('_'* [A-Z])+ !([A-Za-z0-9] / '_');                                                         

op:
   cond_op
 / not_comp_op !'='
 / comp_op;

comp_op:
   '==='
 / '=/='
 / '<='
 / '>=';

cond_op:
   ':' (encloser / not_comp_op) ':' !not_comp_op
 / (encloser / not_comp_op) ':' !not_comp_op;

multi_op:
   '-/->'
 / '<-/-'
 / '-->'
 / '==>'
 / '>>>'
 / '|->'
 / '<<<'
 / '<->'
 / '<-'
 / '<=>'
 / '->'
 / double_right_arrow
 / '>>'
 / '<<'
 / '**'
 / '!!'
 / '::'
 / !right_encloser_multi '///'
 / !right_encloser_multi '//';

// The definition in Rats! uses a function the test if the character read is a valid operator
single_op:
   !(encloser / left_encloser / right_encloser / multi_op / comp_op / '=>') .;

not_comp_op:
   op_name
 / multi_op
 / single_op;

compound_op:
   not_comp_op '=';

/* The operator "=>" should not be in the left-hand sides of case/typecase expressions. */
double_right_arrow:
   '=>' &(w block_elems w '=>');

/* The operator "BY" should not be used with ExtentRange. */
cross_op:
   'BY' &(w extent_range);

less_than_equal:
   '<=' / 'LE';

less_than:
   '<' / 'LT';

greater_than_equal:
   '>=' / 'GE';

greater_than:
   '>' / 'GT';

implies:
   '->' / 'IMPLIES';

assign_op:
   ':='
 / compound_op;

accumulator:
   'SUM'
 / 'PROD'
 / 'BIG' w (encloser / op);

array_comprehension_clause:
   array_comprehension_left wr bar wr generator_clause_list;

//-------------------------------------------------------------------------
//  Identifiers
//-------------------------------------------------------------------------

id:
   !(keywords / op_name) (id_start id_rest+ / unicode_id_start) ;  // It can not be '_'

id_start:
   unicode_id_start / '_';

id_rest:
   '_' / '\'' / unicode_id_rest;

unicode_id_start:  // In the original rats file definition, this nonterminal allow the set of unicode characters
   [a-zA-Z];

unicode_id_rest:
   [a-zA-Z0-9];

bind_id:
   id / '_'; 

bind_id_list:
   bind_id (w ',' w bind_id)*;

bind_id_or_bind_tuple:
   bind_id
 / '(' w bind_id w ',' w bind_id_list w ')';

simple_name:
   id
 / 'opr' w op
 / 'opr' w encloser_pair;

api_name:
   qualified_name;

qualified_name:
   id &(w '...')                // it ignores the dots
 / id ('.' id)* &(w '...')       // it ignores the dots
 / id ('.' id)*;

//-------------------------------------------------------------------------
//  Keywords
//-------------------------------------------------------------------------

keywords:
   key !id_rest;

key:
   'absorbs'
 / 'abstract'
 / 'also'
 / 'api'
 / 'as'
 / 'asif'
 / 'at'
 / 'atomic'
 / 'bool'
 / 'case'
 / 'catch'
 / 'coerce'
 / 'coerces'
 / 'component'
 / 'comprises'
 / 'default'
 / 'dim'
 / 'do'
 / 'elif'
 / 'else'
 / 'end'
 / 'ensures'
 / 'except'
 / 'excludes'
 / 'exit'
 / 'export'
 / 'extends'
 / 'finally'
 / 'fn'
 / 'for'
 / 'forbid'
 / 'from'
 / 'getter'
 / 'hidden'
 / 'if'
 / 'import'
 / 'int'
 / 'invariant'
 / 'io'
 / 'juxtaposition'
 / 'label'
 / 'most'
 / 'nat'
 / 'native'
 / 'object'
 / 'of'
 / 'opr'
 / 'or'
 / 'override'
 / 'private'
 / 'property'
 / 'provided'
 / 'requires'
 / 'self'
 / 'settable'
 / 'setter'
 / 'spawn'
 / 'syntax'
 / 'test'
 / 'then'
 / 'throw'
 / 'throws'
 / 'trait'
 / 'transient'
 / 'try'
 / 'tryatomic'
 / 'type'
 / 'typecase'
 / 'unit'
 / 'value'
 / 'var'
 / 'where'
 / 'while'
 / 'widens'
 / 'with'
 / 'wrapped'
 / 'goto'
 / 'idiom'
 / 'public'
 / 'pure'
 / 'reciprocal'
 / 'static';

keyword_operator:
   key_op ! id_rest;

key_op:
   'juxtaposition'
 / 'in'
 / 'per'
 / 'square'
 / 'cubic'
 / 'inverse'
 / 'squared'
 / 'cubed';

// BIG, FORALL, SI_unit

//-------------------------------------------------------------------------
//  Spaces and Comments
//-------------------------------------------------------------------------

end_of_file:
   !.;

white_space:
   space / new_line;

space:
   ' '
 / '\f'
 / no_new_line_comment;

new_line:
   '\r\n'
 / '\r'
 / '\n'
 / comment;

no_new_line_comment:
   '(*' no_new_line_comment_content* '*)';

no_new_line_comment_content:
   no_new_line_comment
 / '*' !')'
 / !'*' !new_line .;

comment:                        // it comment may have new lines.
   '(*' comment_content* '*)';

comment_content:
   comment 
 / '*' !')'
 / !'*' .; 

w:
   white_space*;
  
wr:
   white_space+;

s:
   space*;
   
sr:
   space+;

nl:
   s new_line w;

br:
   nl / s ';' w;

rect_separator:
   (w ';')+ w
 / sr
 / nl; 

 //-------------------------------------------------------------------------
//  TODO
//-------------------------------------------------------------------------

is_type:
   TODO;

array_expr:
   TODO;

mods:
   'var';

pattern:
   TODO;

type_or_pattern:
   TODO;

static_params:
   TODO;

fn_header_clause:
   TODO;

init_val:
   TODO;

no_new_line_pattern:
   TODO;

int_expr:
   int_literal;

int_literal:
   '0' / [1-9] [0-9]*;

throws:
   'throws' w '{' w '}';

extends_where:
   TODO;

go_in_an_object:
   TODO;

trait_types:
   TODO;

no_space_expr:
   TODO;

decls:
   TODO;

abs_decls:
   'trait' w id w 'end';

static_args:
   '[\\' w 'Unity' w '\\]';

TODO:
   'TODO';