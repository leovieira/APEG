apeg Fortress;

//-------------------------------------------------------------------------
//  Components and APIs - Compilation.rats
//-------------------------------------------------------------------------

file:
   w program w !.;

program:
   compilation_unit
 / import_or_exports (w ';')? w decls (w ';')?
 / imports (w ';')? (w abs_decls (w ';')?)?
 / (imports (w ';')? w)? abs_decls (w ';')?;

compilation_unit:
   component
 / api;
 
component:
   ('native' w)? 'component' w api_name w 'comprises' w api_names (w import_or_exports (w ';')?)? w 'end' ((s 'component')? s api_name)?
 / ('native' w)? 'component' w api_name w imports? w export w import_or_export? (w ';')? (w decls (w ';')?)? w 'end' ((s 'component')? s api_name)?;

api:
   'api' w api_name w 'comprises' w api_names w 'end' ((s 'api')? s api_name)?
 / 'api' w api_name (w imports (w ';')?)? (w abs_decls (w ';')?)? w 'end' ((s 'api')? s api_name)?;

import_or_exports:
   import_or_export (br import_or_export)*;

import_or_export:
   import
 / export;

imports:
   import (br import)*;

import:
   'import' (w foreign_lang)? w 'api' w aliased_api_names
 / 'import' w imported_names;

foreign_lang:
   !(id w '.') id
 / string_literal_expr;

imported_names:
   (foreign_lang w)? api_name '.' w '{' w '...' w '}' (w 'except' w simple_names)?
 / foreign_lang w api_name '.' w '{' w aliased_qualified_name_list (w ',' w '...')? w '}'
 / (foreign_lang w)? api_name '.' w '{' w aliased_simple_name_list (w ',' w '...')? w '}'
 / (foreign_lang w)? id '.' qualified_name (w '=>' w id)?;

simple_names:
   simple_name
 / '{' w simple_name (w ',' w simple_name)* w '}';

aliased_simple_name:
   id (w '=>' w id)?
 / 'opr' (w 'BIG')? w encloser_pair (w '=>' w encloser_pair)?
 / 'opr' (w 'BIG')? w (encloser / op) (w '=>' w (encloser / op))?;

aliased_simple_name_list:
   aliased_simple_name (w ',' w aliased_simple_name)*;

aliased_qualified_name:
   qualified_name (w '=>' w qualified_name)?;

aliased_qualified_name_list:
   aliased_qualified_name (w ',' w aliased_qualified_name)*;

aliased_api_name:
   api_name (w '=>' w id)?;

aliased_api_names:
   aliased_api_name
 / '{' w aliased_api_name (w ',' w aliased_api_name)*;

export:
   'export' w api_names;

api_names:
   api_name
 / '{' w api_name (w ',' w api_name)* w '}';

//-------------------------------------------------------------------------
//  Top-level Declarations - Declaration.rats
//-------------------------------------------------------------------------

decls:
   decl (br decl)*;

decl:
   trait_decl
 / object_decl
 / var_decl
 / top_level_fn_decl
 / dim_unit_decl
 / type_alias
 / test_decl
 / property_decl;

abs_decls:
   abs_decl (br abs_decl)*;

abs_decl:
   abs_trait_decl
 / abs_object_decl
 / abs_var_decl
 / dim_unit_decl
 / type_alias
 / test_decl
 / property_decl
 / grammar_def;

//-------------------------------------------------------------------------
//  Trait and Object Declarations - TraitObject.rats
//-------------------------------------------------------------------------

trait_decl:
   mods? trait_header_front (w trait_clause)* (w go_in_a_trait)? w 'end' ((s 'trait')? s id)?;

trait_header_front:
   'trait' w id (w static_params)? (w trait_val_param)? (w extends_where)?;

trait_val_param:
   '(' (w trait_params)? w ')';

trait_params:
   trait_param (w ',' w trait_param)*;

trait_param:
   bind_id w is_type;

trait_clause:
   excludes
 / comprises
 / where;

go_in_a_trait:
   goes_in_a_trait (br goes_in_a_trait)*;

goes_in_a_trait:
   coercion
 / abs_var_decl
 / md_decl
 / property_decl;

object_decl:
   mods? object_header (w go_in_an_object)? w 'end' ((s 'object')? s id)?;

object_header:
   'object' w id (w static_params)? (w object_val_param)? (w extends_where)? fn_clauses;

object_val_param:
   '(' (w object_params)? w ')';

object_parameter:
   object_param w '=' w expr
 / object_param;

object_params:
   object_parameter (w ',' w object_parameter)*;

object_param:
   mods? plain_param;

go_in_an_object:
   goes_in_an_object (br goes_in_an_object)*;

goes_in_an_object:
   coercion
 / var_decl
 / md_decl
 / property_decl;

abs_trait_decl:
   mods? trait_header_front (w trait_clause)*
     (w abs_go_in_a_trait)? w 'end' ((s 'trait')? s id)?;

abs_go_in_a_trait:
   abs_goes_in_a_trait (br abs_goes_in_a_trait)*;

abs_goes_in_a_trait:
   coercion
 / abs_var_decl
 / property_decl;

abs_object_decl:
   mods? object_header (w abs_go_in_an_object)? w 'end' ((s 'object')? s id)?;

abs_go_in_an_object:
   abs_goes_in_an_object (br abs_goes_in_an_object)*;

abs_goes_in_an_object:
   coercion
 / abs_var_decl
 / property_decl;
 

//-------------------------------------------------------------------------
//  Variable Declarations - Variable.rats
//-------------------------------------------------------------------------

var_decl:
   mods? var_may_types w init_val
 / mods? bind_id_or_bind_tuple w '=' w no_new_line_expr
 / mods? bind_id_or_bind_tuple w ':' w no_new_line_type w '...' w init_val
 / mods? bind_id_or_bind_tuple w ':' w no_new_line_tuple_type w w init_val;

var_may_types:
   var_may_type
 / '(' w var_may_type (w ',' w var_may_type)+ w ')';

var_may_type:
   bind_id (w is_type_or_pattern)?;

init_val:
   ('=' / ':=') w no_new_line_expr;

abs_var_decl:
   mods? no_new_line_var_w_types
 / mods? bind_id_or_bind_tuple w ':' w no_new_line_type w '...'
 / mods? bind_id_or_bind_tuple w ':' w no_new_line_tuple_type;

//-------------------------------------------------------------------------
//  Function Declarations - Function.rats
//-------------------------------------------------------------------------

top_level_fn_decl:
   fn_decl;

fn_decl:
   mods? fn_header_front fn_header_clause w '=' w no_new_line_expr
 / abs_fn_decl;

abs_fn_decl:
   mods? abs_fn_header_front fn_header_clause
 / fn_sig;

fn_header_front:
   named_fn_header_front
 / op_header_front;

abs_fn_header_front:
   abs_named_fn_header_front
 / abs_op_header_front;

named_fn_header_front:
   id (w static_params)? w val_param;

abs_named_fn_header_front:
   id (w static_params)? w abs_val_param;

fn_sig:
   simple_name w ':' w no_new_line_type;

//-------------------------------------------------------------------------
//  Dimiension, Unit, Type Alias, Test, Property - OtherDecl.rats
//-------------------------------------------------------------------------

dim_unit_decl:
   'dim' w id (w '=' w no_new_line_type)? s ('unit' / 'SI_unit') w id (wr id)* (w '=' w no_new_line_expr)?
 / 'dim' w id (w '=' w no_new_line_type)? (w 'default' w id)?
 / ('unit' / 'SI_unit') w id (wr id)*;

type_alias:
   'type' w id (w static_params)? w '=' w no_new_line_type; 

test_decl:
   'test' w id w '[' w generator_clause_list w ']' w '=' w no_new_line_expr;

property_decl:
   'property' (w id w '=')? (w 'FORALL' w val_param)? w no_new_line_expr;

//-------------------------------------------------------------------------
//  Header without Newlines - NoNewlineHeader.rats
//-------------------------------------------------------------------------

extends_where:
   'extends' w trait_type_where
 / 'extends' w '{' w trait_type_where (w ',' w trait_type_where)* w '}';

trait_type_where:
   trait_type (w where)?;

extends:
   'extends' w trait_types;

excludes:
   'excludes' w trait_types;

trait_types:
   trait_type
 / '{' w trait_type (w ',' w trait_type)* w '}';

comprises:
   'comprises' w comprising_types
 / 'comprises' w '{' w abs_comprising_type_list w '}';

abs_comprising_type_list:
   '...'
 / comprising_type_list (w ',' w '...')?;

comprising_types:
   comprising_type
 / '{' w comprising_type_list w '}';

comprising_type_list:
   comprising_type (w ',' w comprising_type)*;

comprising_type:
   trait_type
 / id;

where:
   'where' w '[\\' w where_binding (w ',' w where_binding)* w '\\]' (w '{' w where_constraint_list w '}')?
 / 'where' w '{' w where_constraint_list w '}';

where_binding:
   'nat' w id_or_op_name
 / 'int' w id_or_op_name
 / 'bool' w id_or_op_name
 / 'unit' w id_or_op_name
 / id_or_op_name (w extends)?;

fn_header_clause:
   (w no_new_line_type_or_none)? fn_clauses;

fn_clauses:
   fn_clause*;

fn_clause:
   w throws
 / w where
 / w requires
 / w ensures
 / w invariant
 / w extends_where;

throws:
   'throws' w '{' w '}'
 / 'throws' w trait_type;

mods:
   (mod w)+;

mod:
   'abstract'
 / 'atomic'
 / 'getter'
 / 'hidden'
 / 'io'
 / 'override'
 / 'private'
 / 'settable'
 / 'setter'
 / 'test'
 / 'value'
 / 'var'
 / 'wrapped';

static_params:
   '[\\' w static_param (w ',' w static_param)* '\\]';

static_param:
   'nat' w id_or_op_name
 / 'int' w id_or_op_name
 / 'bool' w id_or_op_name
 / 'dim' w id_or_op_name
 / 'unit' w id_or_op_name (w ':' w no_new_line_type)? (w 'absorbs' w 'unit')?
 /  'opr' w op
 / id_or_op_name (w extends)? (w 'absorbs' w 'unit')?; 

//-------------------------------------------------------------------------
//  Header Maybe with Newlines - MayNewlineHeader.rats
//-------------------------------------------------------------------------

pattern:
   type_ref w pattern_val_param
 / !('(' w ')' / tuple_type) pattern_val_param !(w ('->' / '.' / '/' / 'per' / 'square' / 'cubic' / 'inverse' / 'squared' / 'cubed'));

pattern_val_param:
   '(' (w pattern_params)? w ')';

type_or_pattern:
   pattern
 / type;

is_type_or_pattern:
   ':' w pattern
 / is_type;

pattern_params:
   (pattern_param w ',' w)* pattern_keyword (w ',' w pattern_keyword)*
 / pattern_param (w ',' w pattern_param)*;

pattern_param:
   pattern_plain_param
 / pattern_val_param;

pattern_keyword:
   pattern_plain_param w '=' w id;

pattern_plain_param:
   bind_id w is_type_or_pattern
 / pattern
 / !bind_id type
 / bind_id;

no_new_line_pattern:
   type_ref s pattern_val_param
 / !('(' w ')' / tuple_type) pattern_val_param !(w ('->' / '.' / '/' / 'per' / 'square' / 'cubic' / 'inverse' / 'squared' / 'cubed'));

is_type:
   ':' w type;

where_constraint_list:
   where_constraint (w ',' w where_constraint)*;

where_constraint:
   id_or_op_name w extends
 / type_alias
 / type w 'coerces' w type
 / type w 'widens' w type
 / unit_constraint
 / int_expr w '<=' w int_expr                         // here begins the definition of a int_constraint
 / int_expr w '<' w int_expr
 / int_expr w '>=' w int_expr
 / int_expr w '>' w int_expr
 / int_expr w '=' w int_expr                         // here ends the definition of a int_constraint
 / bool_expr
 / type w 'widens' w 'or' w 'coerces' w type;

unit_constraint:
   'dimensionless' w '=' w id_or_op_name
 / id_or_op_name w '=' w 'dimensionless';

int_val:
   int_literal_expr
 / qualified_name;

int_expr:
   sum_expr (w '+' w sum_expr / w '-' w sum_expr)*;

sum_expr:
   mul_expr ((w '.' w / sr) mul_expr)*;

mul_expr:
   int_base '^' int_val
 / int_base;

int_base:
   int_val
 / '(' w int_expr w ')';

bool_expr:
   op_bool;

op_bool:
   bool_primary
 / bool_prefix;

bool_primary:
   bool_primary_front bool_prefix
 / bool_primary_front wr bool_primary
 / bool_primary_front wr op wr op_bool
 / bool_primary_front;

bool_prefix:
   op op_bool
 / op wr op_bool;

bool_primary_front:
   'true'
 / 'false'
 / qualified_name
 / '(' w op_bool w ')';

unit_val:
   'dimensionless'
 / qualified_name;

unit_expr:
   mul_div_unit ( (w '.' w / sr) mul_div_unit / ('/' / 'per') mul_div_unit )*;

mul_div_unit:
   unit_base '^' unit_val
 / unit_base;

unit_base:
   unit_val
 / '(' w unit_expr w ')';

requires:
   'requires' w '{' (w expr_list)? '}';

ensures:
   'ensures' w '{' (w expr (w 'provided' w expr)? (w ',' w expr (w 'provided' w expr)?)*)? w '}';

invariant:
   'invariant' w '{' (w expr_list)? w '}';

static_args:
   '[\\' w static_arg_list w '\\]';

static_arg_list:
   static_arg (w ',' w static_arg)*;

static_arg:
   op &(w ',' / w '\\]')
 / !(qualified_name (w 
                       ('\\]' / ']' / ',' / '[\\' / '[' / '->' / 'OR' / 'AND' / 'IMPLIES' / '=')
                    )
                     / 'Unity' / 'dimensionless' / 'true' / 'false'
     ) int_expr
 / !(qualified_name (w 
                       ('\\]' / ']' / ',' / '[\\' / '[' / '->')
                    ) 
                    / 'Unity' / 'dimensionless'
     ) bool_expr
 / 'true'
 / 'false'
 / !(qualified_name (w ('.' / '/' / 'per' / dim_postfix_op)) / 'dimensionless') type
 / unit_expr;

//-------------------------------------------------------------------------
//  Parameters - Parameter.rats
//-------------------------------------------------------------------------

val_param:
   bind_id
 / '(' (w params)? w ')';

abs_val_param:
   '(' (w abs_params)? w ')'
 / type;

parameter:
   keyword
 / var_args
 / param;

params:
   parameter (w ',' w parameter)*;

abs_parameter:
   keyword
 / var_args
 / abs_param;

abs_params:
   abs_parameter (w ',' w abs_parameter)*;

var_args:
   bind_id w ':' w type '...';

keyword:
   param w '=' w expr;

param:
   plain_param;

plain_param:
   bind_id (w is_type_or_pattern)?;

abs_param:
   abs_plain_param;

abs_plain_param:
   bind_id w is_type
 / type;

single_op_PARAM:
   op
 / '^'
 / encloser
 / 'SUM'
 / 'PROD';

op_header_front:
   'opr' (w 'BIG')? w (left_encloser w '|->' / left_encloser / encloser) (w static_params)? (w params)? w (right_encloser / encloser)
 / 'opr' w val_param w (op / exponent_op / '^') (w static_params)?
 / 'opr' (w 'BIG')? w single_op_PARAM (w static_params)? w val_param;

abs_op_header_front:
   'opr' (w 'BIG')? w (left_encloser w '|->' / left_encloser / encloser) (w static_params)? (w abs_params)? w (right_encloser / encloser)
 / 'opr' w abs_val_param w (op / exponent_op / '^') (w static_params)?
 / 'opr' (w 'BIG')? w single_op_PARAM (w static_params)? w abs_val_param;

//-------------------------------------------------------------------------
//  Method Declaration - Method.rats
//-------------------------------------------------------------------------

md_decl:
   md_def
 / mods? abs_md_header_front fn_header_clause;

md_def:
   mods? md_header_front fn_header_clause w '=' w no_new_line_expr;

md_header_front:
   named_md_header_front
 / method_op_header_front;

abs_md_header_front:
   abs_named_md_header_front
 / method_abs_op_header_front;

named_md_header_front:
   id (w static_params)? w method_val_param;

abs_named_md_header_front:
   id (w static_params)? w method_abs_val_param;

coercion:
   'coerce' (w static_params)? w '(' w bind_id w is_type_or_pattern w ')' fn_clauses (w 'widens')? w '=' w no_new_line_expr;

//-------------------------------------------------------------------------
//  Method Parameters - MethodParam.rats
//-------------------------------------------------------------------------

method_val_param:
   '(' (w method_params)? w ')';

method_abs_val_param:
   '(' (w method_abs_params)? w ')';

method_parameter:
   method_keyword
 / var_args
 / method_param;

method_params:
   method_parameter (w ',' w method_parameter)*;

method_abs_parameter:
   method_keyword
 / var_args
 / method_abs_param;

method_abs_params:
   method_abs_parameter (w ',' w method_abs_parameter)*;

method_keyword:
   method_param w '=' w expr;

method_param:
   plain_param
 / 'self';

method_abs_param:
   'self'
 / abs_plain_param;

method_op_header_front:
   'opr' (w 'BIG')? w (left_encloser w '|->' / left_encloser / encloser) (w static_params)?
            (w method_params)? w (right_encloser / encloser) (w ':=' w '(' w subscript_assign_param w ')')?
 / 'opr' w method_val_param w (op / exponent_op / '^') (w static_params)?
 / 'opr' (w 'BIG')? w single_op_PARAM (w static_params)? w method_val_param;

method_abs_op_header_front:
   'opr' (w 'BIG')? w (left_encloser w '|->' / left_encloser / encloser) (w static_params)?
         (w method_abs_params)? w (right_encloser / encloser) (w ':=' w '(' w abs_subscript_assign_param w ')')?
 / 'opr' w method_abs_val_param w (op / exponent_op / '^') (w static_params)?
 / 'opr' (w 'BIG')? w single_op_PARAM (w static_params)? w method_abs_val_param;

subscript_assign_param:
   var_args
 / method_param;

abs_subscript_assign_param:
   var_args
 / method_abs_param;
   

//-------------------------------------------------------------------------
//  Expressions - Expression.rats
//-------------------------------------------------------------------------

expr:
//   expr_front expr_tail*;
param_local w (':=' / '+=') w int_literal_expr / id / literal_expr;

expr_front:
   assign_expr
 / op_expr
 / delimited_expr
 / flow_expr
 / 'fn' w bind_id (w throws)? w '=>' w expr
 / 'fn' w '(' (w params)? w ')' (w is_type)? (w throws)? w '=>' w expr;

expr_tail:
   w 'typed' w type
 / w 'asif' w type;

assign_expr:
   assign_lefts w assign_op w expr;

assign_lefts:
   '(' w assign_left (w ',' w assign_left)* w ')'
 / assign_left;

assign_left:
   primary_front assing_left_tail+
 / qualified_name;

assing_left_tail:
   subscript_assign
 / field_selection_assign;

subscript_assign:
   left_encloser (w static_args)? (w expr_list)? w right_encloser;

field_selection_assign:
   '.' id;

op_expr:
   op_expr_no_enc
 / op_expr_left_encloser
 / encloser;

op_expr_no_enc:
   op_expr_primary
 / op_expr_prefix
 / op;

tight_infix_right:
   encloser op_expr_primary
 / encloser op_expr_prefix
 / encloser wr op_expr_primary
 / encloser wr loose_infix_EXPR
 / encloser wr left_loose_infix
 / encloser;

left_loose_infix:
   op_expr_left_encloser
 / encloser wr op_expr_primary
 / encloser wr op_expr_prefix
 / encloser wr op_expr_left_encloser;

op_expr_left_encloser:
   encloser op_expr_no_enc;

op_expr_primary:
   primary tight_infix_postfix_EXPR
 / primary tight_infix_right
 / primary wr op_expr_primary
 / primary wr loose_infix_EXPR
 / primary wr left_loose_infix
 / primary;

op_expr_prefix:
   op op_expr_primary
 / op op_expr_prefix
 / op op_expr_left_encloser
 / op wr op_expr_primary
 / op wr op_expr_prefix
 / op wr op_expr_left_encloser;

tight_infix_postfix_EXPR:
   op op_expr_primary
 / op op_expr_primary
 / op op_expr_left_encloser
 / op wr op_expr_primary
 / op wr op_expr_prefix
 / op wr op_expr_left_encloser
 / op;

loose_infix_EXPR:
   op wr op_expr_primary
 / op wr op_expr_prefix
 / op wr op_expr_left_encloser;

primary:
   primary_item (w ',' w primary_item)*;

primary_item:
   left_associated_primary
 / math_primary;

left_associated_primary:
   dotted_id_chain w static_args parenthesis_delimited parenthesis_delimited_left* selector*
 / dotted_id_chain subscripting_left+ parenthesis_delimited_left* selector*
 / dotted_id_chain parenthesis_delimited parenthesis_delimited_left* selector*
 / dotted_id_chain selector*
 / primary_front subscripting_left* parenthesis_delimited_left* selector+;

dotted_id_chain:
   id ('.' w id)+;

math_primary:
   primary_front math_item*;

primary_front:
   array_expr
 / map_expr
 / comprehension
 / left_encloser (w static_args)? (w expr_list)? w right_encloser
 / parenthesis_delimited
 / literal_expr
 / var_or_fn_ref
 / 'self';

var_or_fn_ref:
   id (w static_args)?;

subscripting_left:
   '{' (w static_args)? (w expr_list)? w '}'
 / '[' (w static_args)? (w expr_list)? w ']'
 / left_encloser (w static_args)? (w expr_list)? w right_encloser;

parenthesis_delimited_left:
   parenthesis_delimited;

parenthesis_delimited:
   parenthesized
 / arg_expr
 / '(' w ')';

selector:
   method_invocation_selector
 / field_selection_selector;

method_invocation_selector:
   '.' w id (w static_args)? parenthesis_delimited parenthesis_delimited_left*;

field_selection_selector:
   '.' w id subscripting_left* parenthesis_delimited_left*;

math_item:
   subscripting
 / exponentiation_EXPR
 / parenthesis_delimited
 / literal_expr
 / var_or_fn_ref
 / 'self';

// There are two different definitions od exponentiation in specification and in Rats! files
exponentiation_EXPR:
   '^' exponent
 / exponent_op;

exponent:
   parenthesis_delimited
 / literal_expr
 / id
 / 'self';

flow_expr:
   'exit' (w id)? (w 'with' w expr)?
 / accumulator (w static_args)? (w '[' generator_clause_list w ']')? w expr
 / 'BIG' left_encloser w '|->' (w static_args)? w right_encloser w expr
 / 'BIG' left_encloser w (w static_args)? w right_encloser w expr
 / 'atomic' w atomic_back
 / 'tryatomic' w atomic_back
 / 'spawn' w expr
 / 'throw' w expr;

atomic_back:
   assign_expr
 / op_expr
 / delimited_expr;

generator_clause_list:
   generator_binding (w ',' w generator_clause)*;

generator_binding:
   bind_id_or_bind_tuple w '<-' w expr;

generator_clause:
   generator_binding
 / expr; 

subscripting:
   '[' (w static_args)? (w expr_list)? w ']'
 / '{' (w static_args)? (w expr_list)? w '}'
 / left_encloser (w static_args)? (w expr_list)? w right_encloser;

//-------------------------------------------------------------------------
//  Expressions Enclosed by Keywords or Symbols - DelimitedExpr.rats
//-------------------------------------------------------------------------

delimited_expr locals[String n1, String n2]:
   arg_expr
 / parenthesized
 / 'object' (wr extends_where)? (nl go_in_an_object)? w 'end'
 / do
 / 'label' wr n1=id w block_elems w 'end' wr n2=id {? n1 == n2}
 / 'while' wr generator_clause w do
 / 'for' wr generator_clause_list w do_front w 'end'
 / 'if' wr generator_clause w 'then' w block_elems (w elifs)? (w else)? w 'end'
 / '(' w 'if' wr generator_clause w 'then' wr block_elems (w elifs)? w else (w 'end')? w ')'
 / 'case' wr expr (w (encloser / op))? w 'of' wr case_clauses (br case_else)? w 'end'
 / 'case' wr 'most' (encloser / op) wr 'of' wr case_clauses w 'end'
 / 'typecase' wr expr w 'of' w type_case_clauses (br case_else)? w 'end'
 / 'try' wr block_elems (w catch)? (w 'forbid' wr trait_types)? (w 'finally' w block_elems)? w 'end';

do:
   (do_front w 'also' w)* do_front w 'end';

do_front:
   ('at' w expr w)? ('atomic' w)? 'do' (w block_elems)?;

arg_expr:
   '(' w (expr w ',' w)* (expr w '...' w ',' w)? keyword_expr (w ',' w keyword_expr)* w ')'
 / '(' w (expr w ',' w)* expr w '...' w ')'
 / tuple_expr;

tuple_expr:
   '(' w (expr w ',' w)+ expr w ')';

keyword_expr:
   bind_id w '=' w expr;

parenthesized:
   '(' w expr w ')';

elifs:
   elif(w elif)*;

elif:
   'elif' w generator_clause w 'then' w block_elems;

else:
   'else' w block_elems;

case_clauses:
   case_clause (br case_clause)*;

case_else:
   'else' w '=>' w block_elems;

type_case_clauses:
   type_case_clause (br type_case_clause)*;

type_case_clause:
   id w '=>' w block_elems
 / (id w ':' w)? type_or_pattern w '=>' w block_elems;

catch:
   'catch' w bind_id w catch_clauses;

catch_clauses:
   catch_clause (br catch_clause)*;

catch_clause:
   trait_type w '=>' w block_elems;

map_expr:
   left_encloser (w static_args)? w entry_list w right_encloser;

comprehension:
   ('BIG' w)? '[' (w static_args)? w array_comprehension_clause (br array_comprehension_clause)* w 	']'
 / ('BIG' w)? left_encloser (w static_args)? w entry wr '|' wr generator_clause_list w right_encloser
 / ('BIG' w)? left_encloser (w static_args)? w expr wr '|' wr generator_clause_list w right_encloser;

/****
 The operator "|->" should not be in the left-hand sides of map expressions
 and map/array comprehensions.
****/
mapsto_op:
   '|->' !(w expr (w '|->' / wr '|' / w '}' / w ','));

/****
 The operator "<-" should not be in the left-hand sides of
 generator clause lists.
*****/
left_arrow_op:
   '<-' !(w expr (w '<-' / w ','));

entry:
   expr w '|->' w expr;

array_comprehension_left:
   id_or_int w '|->' w expr
 / '(' w id_or_int w ',' w id_or_int_list w ')' w '|->' w expr;

id_or_int:
   id
 / int_literal_expr;

id_or_int_list:
   id_or_int (w ',' w id_or_int)*;

expr_list:
   expr (w ',' w expr)*;

entry_list:
   entry (w ',' w entry)*;

//-------------------------------------------------------------------------
//  Expressions without Newlines - NoNewlineExpr.rats
//-------------------------------------------------------------------------

no_new_line_expr:
//   no_new_line_expr_front no_new_line_expr_tail*;
expr;

no_new_line_expr_front:
   no_new_line_assign_expr
 / no_new_line_op_expr
 / delimited_expr
 / no_new_line_flow_expr
 / 'fn' w bind_id (w throws)? w '=>' w no_new_line_expr
 / 'fn' w '(' (w params)? w ')' (w is_type)? (w throws)? w '=>' w no_new_line_expr;

no_new_line_expr_tail:
   s 'typed' w no_new_line_type
 / s 'asif' w no_new_line_type;

no_new_line_assign_expr:
   assign_lefts s assign_op w no_new_line_expr;

no_new_line_op_expr:
   no_new_line_op_expr_no_enc
 / no_new_line_op_expr_left_encloser
 / encloser;

no_new_line_op_expr_no_enc:
   no_new_line_op_expr_primary
 / no_new_line_op_expr_prefix
 / op;

no_new_line_tight_infix_right:
   encloser no_new_line_op_expr_primary
 / encloser no_new_line_op_expr_prefix
 / encloser sr no_new_line_op_expr_primary
 / encloser sr no_new_line_loose_infix_EXPR
 / encloser sr no_new_line_left_loose_infix
 / encloser;

no_new_line_left_loose_infix:
   no_new_line_op_expr_left_encloser
 / encloser sr no_new_line_op_expr_primary
 / encloser sr no_new_line_op_expr_prefix
 / encloser sr no_new_line_op_expr_left_encloser;

no_new_line_op_expr_left_encloser:
   encloser no_new_line_op_expr_no_enc;

no_new_line_op_expr_primary:
   primary no_new_line_tight_infix_postfix_EXPR
 / primary no_new_line_tight_infix_right
 / primary sr no_new_line_op_expr_primary
 / primary sr no_new_line_loose_infix_EXPR
 / primary sr no_new_line_left_loose_infix
 / primary;

no_new_line_op_expr_prefix:
   op no_new_line_op_expr_primary
 / op no_new_line_op_expr_prefix
 / op no_new_line_op_expr_left_encloser
 / op sr no_new_line_op_expr_primary
 / op sr no_new_line_op_expr_prefix
 / op sr no_new_line_op_expr_left_encloser;

no_new_line_tight_infix_postfix_EXPR:
   op no_new_line_op_expr_primary
 / op no_new_line_op_expr_primary
 / op no_new_line_op_expr_left_encloser
 / op sr no_new_line_op_expr_primary
 / op sr no_new_line_op_expr_prefix
 / op sr no_new_line_op_expr_left_encloser
 / op;

no_new_line_loose_infix_EXPR:
   op wr no_new_line_op_expr_primary
 / op wr no_new_line_op_expr_prefix
 / op sr no_new_line_op_expr_left_encloser;

no_new_line_generator_binding:
   bind_id_or_bind_tuple w '<-' w no_new_line_expr;

no_new_line_generator_clause:
   no_new_line_generator_binding
 / no_new_line_expr; 

no_new_line_flow_expr:
   'exit' (w id)? (w 'with' w no_new_line_expr)?
 / accumulator (w static_args)? (w '[' generator_clause_list w ']')? w no_new_line_expr
 / 'BIG' left_encloser w '|->' (w static_args)? w right_encloser w no_new_line_expr
 / 'BIG' left_encloser w (w static_args)? w right_encloser w no_new_line_expr
 / 'atomic' w no_new_line_atomic_back
 / 'tryatomic' w no_new_line_atomic_back
 / 'spawn' w no_new_line_expr
 / 'throw' w no_new_line_expr;

no_new_line_atomic_back:
   assign_expr
 / no_new_line_op_expr
 / delimited_expr;

no_new_line_generator_clause_list:
   generator_binding (s ',' w no_new_line_generator_clause)*;

no_new_line_var_w_types:
   no_new_line_var_w_type
 / '(' w no_new_line_var_w_type (w ',' w no_new_line_var_w_type)+ w ')';

no_new_line_var_w_type:
   bind_id s no_new_line_is_type;

no_new_line_is_type:
   ':' w no_new_line_type;

no_new_line_is_type_or_none:
   ':' w no_new_line_type_or_none;

no_new_line_type_or_none:
   no_new_line_type
 / 'None';

//-------------------------------------------------------------------------
//  Expressions within Array Expressions - NoSpaceExpr.rats
//-------------------------------------------------------------------------

no_space_expr:
   no_space_expr_front;

no_space_expr_front:
   no_space_assign_expr
 / no_space_op_expr
 / delimited_expr;

no_space_assign_expr:
   assign_lefts w assign_op w no_space_expr;

no_space_op_expr:
   no_space_op_expr_no_enc
 / no_space_op_expr_left_encloser
 / encloser;

no_space_op_expr_no_enc:
   no_space_op_expr_primary
 / no_space_op_expr_prefix
 / op;

no_space_tight_infix_right:
   encloser no_space_op_expr_primary
 / encloser no_space_op_expr_prefix
 / encloser;

no_space_op_expr_left_encloser:
   encloser no_space_op_expr_no_enc;

no_space_op_expr_primary:
   primary no_space_tight_infix_postfix
 / primary no_space_tight_infix_right
 / primary;

no_space_op_expr_prefix:
   op no_space_op_expr_primary
 / op no_space_op_expr_prefix
 / op no_space_op_expr_left_encloser;

no_space_tight_infix_postfix:
   op no_space_op_expr_primary
 / op no_space_op_expr_primary
 / op no_space_op_expr_left_encloser
 / op;

//-------------------------------------------------------------------------
//  Local Declarations - LocalDecl.rats
//-------------------------------------------------------------------------

block_elems: // Inserir catch_clause na definição, pois acredito que faltava
   block_elem br block_elems
 / block_elem w ';' &(w 'elif' / w 'also' / w 'end' / w 'catch' / w 'forbid' / w 'finally' / w ')')
 / block_elem &(w 'elif' / w 'also' / w 'end' / w 'catch' / w 'forbid' / w 'finally' / w ')')
 / block_elem &(w else / br catch_clause / br case_clause / br (id w ':' w)? type_or_pattern / br case_else)
 / block_elem w ';' &(w else);

block_elem:
   local_var_fn_decl
 / no_new_line_expr (s ',' w no_new_line_generator_clause_list)?;

local_var_fn_decl:
   local_fn_decl (br local_fn_decl)*
 / local_var_decl;

local_fn_decl:
   mods? id (w static_params)? w val_param_local fn_header_clause w '=' w no_new_line_expr;

val_param_local:
   '(' (w params_local)? w ')'
 / bind_id;

params_local:
   (param_local w ',' w)* (var_args_local w ',' w)? keyword_local (w ',' w keyword_local)*
 / (param_local w ',' w)* var_args_local
 / param_local (w ',' w param_local)*;

param_local:
   bind_id s ':' s pattern
 / bind_id s ':' s no_new_line_type
 / bind_id; 

var_args_local:
   bind_id s ':' s no_new_line_type '...';

keyword_local:
   param_local s '=' w no_new_line_expr;

local_var_decl:
   ('var' w)? local_var_may_types s '=' w no_new_line_expr
 / ('var' w)? no_new_line_var_w_type_or_patterns s ':=' w no_new_line_expr
 / ('var' w)? no_new_line_var_w_types
 / var_wo_types s '=' w no_new_line_expr
 / ('var' w)? var_wo_types s ':' s no_new_line_type s '...' (s init_val)? 
 / ('var' w)? var_wo_types s ':' s tuple_type s '...' (s init_val)?;

local_var_may_types:
   local_var_may_type
 / '(' w local_var_may_type (w ',' w local_var_may_type)+ w ')';

local_var_may_type:
   bind_id (s ':' s (no_new_line_pattern / no_new_line_type))?;

var_wo_types:
   var_wo_type
 / '(' w var_wo_type (w ',' w var_wo_type)+ w ')';

var_wo_type:
   bind_id
 / unpasting;

no_new_line_var_w_type_or_patterns:
   no_new_line_var_w_type_or_pattern
 / '(' w no_new_line_var_w_type_or_pattern (w ',' w no_new_line_var_w_type_or_pattern)+ w ')';

no_new_line_var_w_type_or_pattern:
   bind_id s no_new_line_is_type_or_pattern;

no_new_line_is_type_or_pattern:
   ':' s no_new_line_pattern
 / ':' s no_new_line_type;

unpasting:
   '[' w unpasting_elems w ']';

unpasting_elems:
   unpasting_elem (rect_separator unpasting_elem)*;

unpasting_elem:
   bind_id ('[' w unpasting_dim w ']')?
 / unpasting;

unpasting_dim:
   extent_range ( w 'BY' w extent_range)+;

case_clause:
   no_new_line_expr w '=>' w block_elems;

//-------------------------------------------------------------------------
//  Literals - Literal.rats and NoSpaceLiteral.rats
//-------------------------------------------------------------------------

array_expr:
   '[' (w static_args)? w no_space_expr multi_dim_cons* w ']';

multi_dim_cons:
   rect_separator no_space_expr;

literal_expr:
   '(' w ')'
 / numeric_literal_expr
 / char_literal_expr
 / string_literal_expr;

escape_sequence:
   '\\' ('b' / 't' / 'n' / 'f' / 'r' / '"' / '\\')
 / '\\u' [0-9A-Z] [0-9A-Z] [0-9A-Z] [0-9A-Z]
 / '\\u' [0-9a-f] [0-9a-f] [0-9a-f] [0-9a-f];

numeric_literal_expr:    // there is some differences in Rats! specification about numeric_literal
   float_literal_expr
 / int_literal_expr;

float_literal_expr:
   digit_string '.' digit_string;

int_literal_expr:
   digit_string;

digit_string:
   [0-9]+;

char_literal_expr:
   '\'' char_literal_content '\'';

string_literal_expr:
   '\"' string_literal_content* '\"';

string_literal_content:
   escape_sequence
 / !('\"' / '\\') .;

char_literal_content:
   escape_sequence
 / !('\'' / '\\') .;

//-------------------------------------------------------------------------
//  Types - Type.rats
//-------------------------------------------------------------------------

type:
   !'1' ('io' w)? type_primary (w 'in' w expr)?;

op_type:
   type_primary 
 / type_prefix;

type_primary:
   type_primary_front tight_infix_postfix
 / type_primary_front wr type_primary
 / type_primary_front wr loose_infix
 / type_primary_front;

type_prefix:
   dim_prefix_op type_primary
 / dim_prefix_op type_prefix
 / dim_prefix_op wr type_primary
 / dim_prefix_op wr type_prefix;

tight_infix_postfix:
   '->' type_primary (w throws)?
 / '->' type_prefix (w throws)?
 / dim_infix_op type_primary
 / dim_infix_op type_prefix
 / dim_postfix_op wr type_primary
 / dim_postfix_op wr type_prefix
 / dim_postfix_op;

loose_infix:
   '->' wr type_primary (w throws)?
 / '->' wr type_prefix (w throws)?
 / dim_infix_op wr type_primary
 / dim_infix_op wr type_prefix;

type_infix_op:
   '->';

dim_infix_op:
   'DOT'
 / '/'
 / 'per';

type_primary_front:
   type_front type_tail*; // na definição não exige espaço. Achei estranho!

type_front:
   parenthesized_type
 / domain
 / tuple_type
 / type_ref
 / void_type
 / '1';

parenthesized_type:
   '(' w type w ')';

domain:
   '(' w (type w ',' w)* (type w '...' w ',' w)? keyword_type (w ',' w keyword_type)* w ')'
 / '(' w (type w ',' w)* type w '...' w ')';

keyword_type:
   bind_id w '=' w type;

tuple_type:
   '(' w type w ',' w type_list w ')';

type_list:
   type (w ',' w type)*;

type_ref:
   'Unity'
 / id static_args?;

void_type:
   '(' w ')';

type_tail:
   array_type_size
 / exponentiation
 / parenthesized_type_left
 / id_left;

array_type_size:
   '[' (w array_size)? w ']';

array_size:
   extent_range (w ',' w extent_range)*;

extent_range:
   (static_args w)? '#' (w static_args)?
 / (static_args w)? ':' (w static_args)?
 / static_args;

exponentiation:
   '^' int_expr
 / '^' '(' w extent_range (w 'BY' w extent_range)* w ')';

parenthesized_type_left:
   '(' w op_type w ')';

id_left:
   id;

dim_prefix_op:
   'square'
 / 'cubic'
 / 'inverse';

dim_postfix_op:
   'squared'
 / 'cubed';

trait_type:
   trait_type_front trait_type_tail+
 / type_ref;

trait_type_front:
   parenthesized_type
 / tuple_type
 / type_ref
 / void_type;

trait_type_tail:
   array_type_size_trait
 / exponentiation_trait;

array_type_size_trait:
   '[' (w array_size)? w ']';

exponentiation_trait:
   '^' int_expr
 / '^' '(' w extent_range (w 'BY' w extent_range)* w ')'; 

//-------------------------------------------------------------------------
//  Types without Newlines - NoNewlineType.rats
//-------------------------------------------------------------------------

no_new_line_type:
   !'1' no_new_line_type_primary (w 'in' w no_new_line_expr)?;

no_new_line_type_list:
   no_new_line_type (w ',' w no_new_line_type)*;

no_new_line_tuple_type:
   '(' w no_new_line_type w ',' w no_new_line_type_list w ')';

no_new_line_type_primary:
   type_primary_front no_new_line_tight_infix_postfix
 / type_primary_front sr no_new_line_type_primary
 / type_primary_front sr no_new_line_loose_infix
 / type_primary_front;

no_new_line_type_prefix:
   dim_prefix_op no_new_line_type_primary
 / dim_prefix_op no_new_line_type_prefix
 / dim_prefix_op sr no_new_line_type_primary
 / dim_prefix_op sr no_new_line_type_prefix;

no_new_line_tight_infix_postfix:
   type_infix_op no_new_line_type_primary (s throws)?
 / type_infix_op no_new_line_type_prefix (s throws)?
 / dim_infix_op no_new_line_type_primary
 / dim_infix_op no_new_line_type_prefix
 / dim_postfix_op sr no_new_line_type_primary
 / dim_postfix_op sr no_new_line_type_prefix
 / dim_postfix_op;

no_new_line_loose_infix:
   type_infix_op sr no_new_line_type_primary (s throws)?
 / type_infix_op sr no_new_line_type_prefix (s throws)?
 / dim_infix_op sr no_new_line_type_primary
 / dim_infix_op sr no_new_line_type_prefix;

//-------------------------------------------------------------------------
//  Symbols and Operators - Symbol.rats
//-------------------------------------------------------------------------

encloser_pair:
   (left_encloser / encloser) (w '.' w)? (right_encloser / encloser);

bar:
   &('|' wr generator_clause_list closing_comprehension) '|';

closing_comprehension:       // In Rats! definiton, a right encloser is a closing comprehension too
   w '}'
 / w '|>'
 / br array_comprehension_clause
 / w ']';

sd:
   ('*' / '.')?;

bars:
   '|' (sd '|')*;

slashes:
   '/' (sd '/')*
 / '\\' (sd '\\')*;

lesses:
   '<' (sd '<')*;

greaters:
   '>' (sd '>')*;

encloser:
   !bar bars !('*' / '.' / '>' / '/' / '\\' / '->');

left_encloser:
   left_encloser_multi
 / !('|') .;

left_encloser_multi:
   '(.' ('/'+ / '\\'+)
 / '[/\\/\\/'
 / '[/\\/'
 / '[' (sd slashes)
 / '{' (sd slashes)
 / lesses sd (slashes / bars)
 / bars sd slashes
 / '{*'
 / '[*'
 / '((.>'
 / '(.<';

right_encloser:
   right_encloser_multi
 / !('|') .;

right_encloser_multi:
   '/'+ '.)'
 / '\\'+ '.)'
 / slashes sd (greaters / bars / ']' / '}')
 / bars sd greaters
 / '*]'
 / '*}'
 / ']'
 / '}'
 / '>.)'
 / '<.))'
 / '/\\/\\/]'
 / '/\\/]';

exponent_op:
   '^T'
 / '^' (encloser / not_comp_op);

//----------------------------------------------------------------
// An operator name has at least two different uppercase letters
// also it does not begin and end with an underscore
//----------------------------------------------------------------
op_name:
   !('SUM' / 'PROD' / 'BY') head_op_name
 / keyword_operator;

head_op_name locals[String ch1, String ch2]:
   ch1=[A-Z] (
        '_'* ch2=[A-Z] !({?ch1 == ch2}) tail_op_name
      / '_'* &[A-Z] head_op_name
     );     

tail_op_name:
   !([A-Za-z0-9] / '_')       // there is no more symbols
 / ('_'* [A-Z])+ !([A-Za-z0-9] / '_');                                                         

op:
   cond_op
 / not_comp_op !'='
 / comp_op;

comp_op:
   '==='
 / '=/='
 / '<='
 / '>=';

cond_op:
   ':' (encloser / not_comp_op) ':' !not_comp_op
 / (encloser / not_comp_op) ':' !not_comp_op;

multi_op:
   '-/->'
 / '<-/-'
 / '-->'
 / '==>'
 / '>>>'
 / '|->'
 / '<<<'
 / '<->'
 / '<-'
 / '<=>'
 / '->'
 / double_right_arrow
 / '>>'
 / '<<'
 / '**'
 / '!!'
 / '::'
 / !right_encloser_multi '///'
 / !right_encloser_multi '//';

// The definition in Rats! uses a function the test if the character read is a valid operator
single_op:
   !(encloser / left_encloser / right_encloser / multi_op / comp_op / '=>') .;

not_comp_op:
   op_name
 / multi_op
 / single_op;

compound_op:
   not_comp_op '=';

/* The operator "=>" should not be in the left-hand sides of case/typecase expressions. */
double_right_arrow:
   '=>' &(w block_elems w '=>');

/* The operator "BY" should not be used with ExtentRange. */
cross_op:
   'BY' &(w extent_range);

less_than_equal:
   '<=' / 'LE';

less_than:
   '<' / 'LT';

greater_than_equal:
   '>=' / 'GE';

greater_than:
   '>' / 'GT';

implies:
   '->' / 'IMPLIES';

assign_op:
   ':='
 / compound_op;

accumulator:
   'SUM'
 / 'PROD'
 / 'BIG' w (encloser / op);

array_comprehension_clause:
   array_comprehension_left wr bar wr generator_clause_list;

//-------------------------------------------------------------------------
//  Identifiers - Identifier.rats
//-------------------------------------------------------------------------

id_or_op_name:
   id
 / op_name;

id:
   !(keywords / op_name) (id_start id_rest+ / unicode_id_start) ;  // It can not be '_'

id_start:
   unicode_id_start / '_';

id_rest:
   '_' / '\'' / unicode_id_rest;

bind_id:
   id / '_'; 

bind_id_list:
   bind_id (w ',' w bind_id)*;

bind_id_or_bind_tuple:
   bind_id
 / '(' w bind_id w ',' w bind_id_list w ')';

simple_name:
   id
 / 'opr' w op
 / 'opr' w encloser_pair;

api_name:
   qualified_name;

qualified_name:
   id &(w '...')                // it ignores the dots
 / id ('.' id)* &(w '...')       // it ignores the dots
 / id ('.' id)*;

//-------------------------------------------------------------------------
//  Unicode.rats
//-------------------------------------------------------------------------

unicode_id_start:  // In the original rats file definition, this nonterminal allow the set of unicode characters
   [a-zA-Z];

unicode_id_rest:
   [a-zA-Z0-9];

//-------------------------------------------------------------------------
//  Keywords - Keyword.rats
//-------------------------------------------------------------------------

keywords:
   key !id_rest;

key:
   'absorbs'
 / 'abstract'
 / 'also'
 / 'api'
 / 'as'
 / 'asif'
 / 'at'
 / 'atomic'
 / 'bool'
 / 'case'
 / 'catch'
 / 'coerce'
 / 'coerces'
 / 'component'
 / 'comprises'
 / 'default'
 / 'dim'
 / 'do'
 / 'elif'
 / 'else'
 / 'end'
 / 'ensures'
 / 'except'
 / 'excludes'
 / 'exit'
 / 'export'
 / 'extends'
 / 'finally'
 / 'fn'
 / 'for'
 / 'forbid'
 / 'from'
 / 'getter'
 / 'hidden'
 / 'if'
 / 'import'
 / 'int'
 / 'invariant'
 / 'io'
 / 'juxtaposition'
 / 'label'
 / 'most'
 / 'nat'
 / 'native'
 / 'object'
 / 'of'
 / 'opr'
 / 'or'
 / 'override'
 / 'private'
 / 'property'
 / 'provided'
 / 'requires'
 / 'self'
 / 'settable'
 / 'setter'
 / 'spawn'
 / 'syntax'
 / 'test'
 / 'then'
 / 'throw'
 / 'throws'
 / 'trait'
 / 'transient'
 / 'try'
 / 'tryatomic'
 / 'type'
 / 'typecase'
 / 'unit'
 / 'value'
 / 'var'
 / 'where'
 / 'while'
 / 'widens'
 / 'with'
 / 'wrapped'
 / 'goto'
 / 'idiom'
 / 'public'
 / 'pure'
 / 'reciprocal'
 / 'static';

keyword_operator:
   key_op ! id_rest;

key_op:
   'juxtaposition'
 / 'in'
 / 'per'
 / 'square'
 / 'cubic'
 / 'inverse'
 / 'squared'
 / 'cubed'
 / 'BIG'
 / 'FORALL'
 / 'SI_init';
 
 // There are more other keywords

//-------------------------------------------------------------------------
//  Spaces and Comments - Spacing.rats
//-------------------------------------------------------------------------

end_of_file:
   !.;

white_space:
   space / new_line;

space:
   ' '
 / '\f'
 / no_new_line_comment;

new_line:
   '\r\n'
 / '\r'
 / '\n'
 / comment;

no_new_line_comment:
   '(*' no_new_line_comment_content* '*)';

no_new_line_comment_content:
   no_new_line_comment
 / '*' !')'
 / !'*' !new_line .;

comment:                        // it comment may have new lines.
   '(*' comment_content* '*)';

comment_content:
   comment 
 / '*' !')'
 / !'*' .; 

w:
   white_space*;
  
wr:
   white_space+;

s:
   space*;
   
sr:
   space+;

nl:
   s new_line w;

br:
   nl / s ';' w;

rect_separator:
   (w ';')+ w
 / sr
 / nl;

//-------------------------------------------------------------------------
// Extensibility - Syntax.rats
//-------------------------------------------------------------------------

grammar_def:
   'native' w 'grammar' w id (br nonterminal_decl)* w 'end'
 / 'grammar' w id (w grammar_extends)? (br nonterminal_def)* w 'end';

grammar_extends:
   'extends' w qualified_names;

qualified_names:
   qualified_name
 / '{' qualified_name (w ',' w qualified_name)* '}';

nonterminal_def:
   id w '|' w ':=' w syntax_extension_def (w syntax_extension_def_or)*
 / nonterminal_header w ':' (w trait_type)? w ':=' w syntax_def (w syntax_def_or)*
 / nonterminal_decl;

nonterminal_decl:
   nonterminal_header w ':' w trait_type;

nonterminal_header:
   ('private' w)? id (w syntax_params)? (w static_params)? (':' w type)? (w where)?;

syntax_params:
   '(' w syntax_param (w ',' w syntax_param)* w ')';

syntax_param:
   id ':' trait_type;

syntax_def:
   (choice_modifier w)? syntax_symbols w '=>' w pre_transformer_decl;

syntax_extension_def:
    syntax_def
  / (super_choice_modifier w)? id w 'from' w id;

syntax_def_or:
   '|' w syntax_def;

syntax_extension_def_or:
   '|' w syntax_extension_def;

choice_modifier:
   'private';

super_choice_modifier:
   'private'
 / 'without';

pre_transformer_decl:
   pre_transformer;

pre_transformer:
   'case' w id w 'of' w case_transformer_clauses w 'end'
 / (id w )? '<[' w (']' !'>' / !']' .)* w ']>';   // Na implementação de Fortress o trecho entre '<[' e ']>' é guardado sem checagem com o parser

case_transformer_clauses:
   case_transformer_clause (br case_transformer_clause)*;

case_transformer_clause:
   id (w '(' w bind_id_list w ')')? w '=>' w pre_transformer;

syntax_symbols:
   syntax_symbol symbs* &(w '=>');

syntax_symbols_x:
   syntax_symbol symbs*;

symbs:
   space_or_breakline+ syntax_symbol;

space_or_breakline:
   (' ' / '\f')+
 / ('\r\n' / '\r' / '\n');

syntax_symbol:
   'NOT' w symbol_mod
 / 'AND' w symbol_mod
 / symbol_mod;

symbol_mod:
   single '?'
 / single '*'
 / single '+'
 / single;

single:
   group_symbol
 / base_symbol;

base_symbol:
   (id ':')? symbol;

group_symbol:
   '{' w syntax_symbols_x w '}';

symbol:
   item '#'?;

item:
   !(w '=>') item_text
 / '[' character_class* ']'
 / '_'
 / 'TAB'
 / 'FORMFEED'
 / 'RETURN'
 / 'NEWLINE'
 / 'SPACE'
 / 'BACKSPACE';

character_class:
   char (':' char)?;

char:
   'TAB'
 / 'FORMFEED'
 / 'RETURN'
 / 'NEWLINE'
 / 'SPACE'
 / 'BACKSPACE'
 / utf16;

item_text:
   !special_symbols utf16+
 / special_symbols utf16+;   // ????? In Rats!, the definition is in that form.

utf16:
   '`' special_chars
 / '`' special_symbols
 / !special_symbols .;

special_chars:
   ' '
 / '\f'
 / '\r\n'
 / '\r'
 / '\n'
 / ':'
 / '?'
 / '#'
 / '+'
 / '*'
 / '['
 / ']'
 / '`'
 / '|'
 / '_'
 / '{'
 / '}';

special_symbols:
   'TAB'
 / 'FORMFEED'
 / 'RETURN'
 / 'NEWLINE'
 / 'SPACE'
 / 'BACKSPACE'
 / 'AND'
 / 'NOT'
 / '=>';
