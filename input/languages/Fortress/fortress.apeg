apeg Fortress;


//-------------------------------------------------------------------------
//  Components and APIs
//-------------------------------------------------------------------------
/*
file:
   compilation_unit w
 / (w imports)? w exports (w decls)? w
 / (w imports)? w abs_decls w
 / w imports (w abs_decls)? w;

compilation_unit:
   w component w
 / w api;
 
component:
   'component' w dotted_id (w imports)? w exports (w decls)? w 'end';

api:
   'api' w dotted_id (w imports)? (w abs_decls)? w 'end';

imports:
   import (wr import)*;

import:
   'import' wr import_from
 / 'import' wr aliased_dotted_ids;

import_from:
   '*' (wr 'except' wr names)? wr 'from' wr dotted_id
 / aliased_names wr 'from' wr dotted_id;

names:
   name
 / '{' w name_list w '}';

name_list:
   name (w ',' w name)*;

aliased_names:
   aliased_name
 / '{' w aliased_name_list w '}';

aliased_name:
   'opr' w op (w 'as' w op)?
 / 'opr' w left_encloser w right_encloser (w 'as' w left_encloser w right_encloser)?
 / id (wr 'as' wr dotted_id)?;

aliased_name_list:
   aliased_name (w ',' w aliased_name)*;

aliased_dotted_ids:
   aliased_dotted_id
 / '{' w aliased_dotted_id_list w '}';

aliased_dotted_id:
   dotted_id (wr 'as' wr dotted_id)?;

aliased_dotted_id_list:
   aliased_dotted_id (w ',' w aliased_dotted_id)*;

exports:
   export (wr export)*;

export:
   'export' wr dotted_ids;

dotted_ids:
   dotted_id
 / '{' w dotted_id_list w '}';

dotted_id_list:
   dotted_id (w ',' w dotted_id)*;
*/
//-------------------------------------------------------------------------
//  Top-level Declarations
//-------------------------------------------------------------------------


//-------------------------------------------------------------------------
//  Types
//-------------------------------------------------------------------------

is_type:
   ':' w type_ref;
   
/* TypeRef and TraitType/ArrowType/DimType are mutually left recursive.
Weâ€™ve inlined them into each other and removed the left recursion. */

type_ref:
   trait_type
 / type_ref_front type_ref_tail*;

type_ref_front:
   tuple_type
 / '(' (w type_ref)? w ')';

trait_type:
   trait_type_front type_ref_tail*;

trait_type_front:
   qualified_name (w '[\\' w static_arg_list w '\\]')?
 / '{' w type_ref w mapsto w type_ref w '}'
 / '<|' w type_ref w '|>';

type_ref_tail:
   array_type_tail
 / matrix_type_tail
 / arrow_type_tail;

array_type_tail:
   w '[' (w array_size)? w ']';

matrix_type_tail:
   '^' static_arg_front
 / '^' '(' w extent_range (w 'BY' w extent_range)* w ')';

arrow_type_tail:
   w '->' w type_ref (w throws)?;

arrow_type:
   (trait_type_front / type_ref_front) arrow_type_action_tail*;

arrow_type_action_tail:
   arrow_type_action;

arrow_type_action:
   w '->' w type_ref (w throws)?;

tuple_type:
   '(' w (type_ref w ',' w)* (type_ref w '...' w ',' w)? keyword_type (w ',' w keyword_type w)* w ')'
 / '(' w (type_ref w ',' w)* type_ref w '...' w ')'
 / simple_tuple_type;

keyword_type:
   id w '=' type_ref;

simple_tuple_type:
   '(' w type_ref w ',' w type_ref_list w ')';

type_ref_list:
   type_ref (w ',' w type_ref)*;

static_arg_list:
   static_arg (w ',' w static_arg)*;

static_arg:
   static_arg_front static_arg_tail*;

static_arg_front:
   number
 / op
 / '1' w '/' w static_arg
 / type_ref
 / '(' static_arg ')';

static_arg_tail:
   sum_static_arg
 / product_static_arg
 / quotient_static_arg
 / exponent_static_arg;

sum_static_arg:
   w '+' w static_arg;

product_static_arg:
   (w '.' w / sr) static_arg;

quotient_static_arg:
   w '/' w static_arg;

exponent_static_arg:
   '^' static_arg;

array_size:
   extent_range (w ',' w extent_range)*;

extent_range:
   (static_arg w)? '#' (w static_arg)?
 / (static_arg w)? ':' (w static_arg)?
 / static_arg;

number:
   int_literal; 
 
//-------------------------------------------------------------------------
//  Symbols and Operators
//-------------------------------------------------------------------------

encloser_pair:
   (left_encloser / encloser) (w '.' w)? (right_encloser / encloser);

bar:
   &('|' wr generator_clause_list closing_comprehension) '|';

closing_comprehension:       // In Rats! definiton, a right encloser is a closing comprehension too
   w '}'
 / w '|>'
 / br array_comprehension_clause
 / w ']';

sd:
   ('*' / '.')?;

bars:
   '|' (sd '|')*;

slashes:
   '/' (sd '/')*
 / '\\' (sd '\\')*;

lesses:
   '<' (sd '<')*;

greaters:
   '>' (sd '>')*;

encloser:
   !bar bars !('*' / '.' / '>' / '/' / '\\' / '->');

left_encloser:
   left_encloser_multi
 / !('|') .;

left_encloser_multi:
   '(.' ('/'+ / '\\'+)
 / '[/\\/\\/'
 / '[/\\/'
 / '[' (sd slashes)
 / '{' (sd slashes)
 / lesses sd (slashes / bars)
 / bars sd slashes
 / '{*'
 / '[*'
 / '((.>'
 / '(.<';

right_encloser:
   right_encloser_multi
 / !('|') .;

right_encloser_multi:
   '/'+ '.)'
 / '\\'+ '.)'
 / slashes sd (greaters / bars / ']' / '}')
 / bars sd greaters
 / '*]'
 / '*}'
 / ']'
 / '}'
 / '>.)'
 / '<.))'
 / '/\\/\\/]'
 / '/\\/]';

exponent_op:
   '^T'
 / '^' (encloser / not_comp_op);

//----------------------------------------------------------------
// An operator name has at least two different uppercase letters
// also it does not begin and end with an underscore
//----------------------------------------------------------------
op_name:
   !(single_accumulator / 'BY') (two_letter_op_name / more_two_letter_name)
 / keyword_operator;   

two_letter_op_name locals[String ch1, String ch2]:
   ch1=[A-Z] ch2=[A-Z] !({? ch1 == ch2}) !([A-Za-z0-9] / '_');      // operators with two different letters

more_two_letter_name locals[String ch1, String ch2]:
   ch1=[A-Z] (
        '_'* ch2=[A-Z] !({?ch1 == ch2}) end_op_name+ !([A-Za-z0-9] / '_')
      / '_'* &[A-Z] more_two_letter_name
     );     

end_op_name:
   '_'* [A-Z];                                                           

op:
   cond_op
 / not_comp_op !'='
 / comp_op;

comp_op:
   '==='
 / '=/='
 / '<='
 / '>=';

cond_op:
   ':' (encloser / not_comp_op) ':' !not_comp_op
 / (encloser / not_comp_op) ':' !not_comp_op;

multi_op:
   '-/->'
 / '<-/-'
 / '-->'
 / '==>'
 / '>>>'
 / mapsto_op
 / '<<<'
 / '<->'
 / '<-'
 / '<=>'
 / '->'
 / double_right_arrow
 / '>>'
 / '<<'
 / '**'
 / '!!'
 / '::'
 / !right_encloser_multi '///'
 / !right_encloser_multi '//';

// The definition in Rats! uses a function the test if the character read is a valid operator
single_op:
   !(encloser / left_encloser / right_encloser / multi_op / comp_op / '=>') .;

not_comp_op:
   op_name
 / multi_op
 / single_op;

compound_op:
   not_comp_op '=';

/* The operator "=>" should not be in the left-hand sides of case/typecase expressions. */
double_right_arrow:
   '=>' &(w block_elems w '=>');

/* The operator "BY" should not be used with ExtentRange. */
cross_op:
   'BY' &(w extent_range);

less_than_equal:
   '<=' / 'LE';

less_than:
   '<' / 'LT';

greater_than_equal:
   '>=' / 'GE';

greater_than:
   '>' / 'GT';

implies:
   '->' / 'IMPLIES';

assign_op:
   ':='
 / compound_op;

single_accumulator:
   'SUM'
 / 'PROD';

accumulator:
   'SUM'
 / 'PROD'
 / 'BIG' w (encloser / op);

array_comprehension_clause:
   array_comprehension_left wr bar wr generator_clause_list;

//-------------------------------------------------------------------------
//  Identifiers
//-------------------------------------------------------------------------

id:
   !(keywords / op_name) (id_start id_rest+ / unicode_id_start) ;  // It can not be '_'

id_start:
   unicode_id_start / '_';

id_rest:
   '_' / '\'' / unicode_id_rest;

unicode_id_start:  // In the original rats file definition, this nonterminal allow the set of unicode characters
   [a-zA-Z];

unicode_id_rest:
   [a-zA-Z0-9];

bind_id:
   id / '_'; 

bind_id_list:
   bind_id (w ',' w bind_id)*;

bind_id_or_bind_tuple:
   bind_id
 / '(' w bind_id w ',' w bind_id_list w ')';

simple_name:
   id
 / 'opr' w op
 / 'opr' w encloser_pair;

api_name:
   qualified_name;

qualified_name:
   id &(w '...')                // it ignores the dots
 / id ('.' id)* &(w '...')       // it ignores the dots
 / id ('.' id)*;

//-------------------------------------------------------------------------
//  Keywords
//-------------------------------------------------------------------------

keywords:
   'absorbs'
 / 'abstract'
 / 'also'
 / 'api'
 / 'as'
 / 'asif'
 / 'at'
 / 'atomic'
 / 'bool'
 / 'case'
 / 'catch'
 / 'coerce'
 / 'coerces'
 / 'component'
 / 'comprises'
 / 'default'
 / 'dim'
 / 'do'
 / 'elif'
 / 'else'
 / 'end'
 / 'ensures'
 / 'except'
 / 'excludes'
 / 'exit'
 / 'export'
 / 'extends'
 / 'finally'
 / 'fn'
 / 'for'
 / 'forbid'
 / 'from'
 / 'getter'
 / 'hidden'
 / 'if'
 / 'import'
 / 'int'
 / 'invariant'
 / 'io'
 / 'juxtaposition'
 / 'label'
 / 'most'
 / 'nat'
 / 'native'
 / 'object'
 / 'of'
 / 'opr'
 / 'or'
 / 'override'
 / 'private'
 / 'property'
 / 'provided'
 / 'requires'
 / 'self'
 / 'settable'
 / 'setter'
 / 'spawn'
 / 'syntax'
 / 'test'
 / 'then'
 / 'throw'
 / 'throws'
 / 'trait'
 / 'transient'
 / 'try'
 / 'tryatomic'
 / 'type'
 / 'typecase'
 / 'unit'
 / 'value'
 / 'var'
 / 'where'
 / 'while'
 / 'widens'
 / 'with'
 / 'wrapped'
 / 'goto'
 / 'idiom'
 / 'public'
 / 'pure'
 / 'reciprocal'
 / 'static';

keyword_operator:
   'juxtaposition'
 / 'in'
 / 'per'
 / 'square'
 / 'cubic'
 / 'inverse'
 / 'squared'
 / 'cubed';

// BIG, FORALL, SI_unit

//-------------------------------------------------------------------------
//  Spaces and Comments
//-------------------------------------------------------------------------

end_of_file:
   !.;

white_space:
   space / new_line;

space:
   ' '
 / '\f'
 / no_new_line_comment;

new_line:
   '\r\n'
 / '\r'
 / '\n'
 / comment;

no_new_line_comment:
   '(*' no_new_line_comment_content* '*)';

no_new_line_comment_content:
   no_new_line_comment
 / '*' !')'
 / !'*' !new_line .;

comment:                        // it comment may have new lines.
   '(*' comment_content* '*)';

comment_content:
   comment 
 / '*' !')'
 / !'*' .; 

w:
   white_space*;
  
wr:
   white_space+;

s:
   space*;
   
sr:
   space+;

nl:
   s new_line w;

br:
   nl / s ';' w;

rect_separator:
   (w ';')+ w
 / sr
 / nl; 

 //-------------------------------------------------------------------------
//  TODO
//-------------------------------------------------------------------------

int_literal:
   '0' / [1-9] [0-9]*;

throws:
   'throws' w '{' w '}';

block_elems:
   TODO;

generator_clause_list:
   TODO;

mapsto:
   mapsto_op;

mapsto_op:
   '|->';

no_new_line_expr:
   TODO;

array_comprehension_left:
   TODO;

decls:
   TODO;

abs_decls:
   'trait' w id w 'end';

TODO:
   'TODO';
