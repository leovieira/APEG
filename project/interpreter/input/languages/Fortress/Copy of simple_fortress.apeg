apeg Fortress;

functions AdaptableFunctions;

//-------------------------------------------------------------------------
//  Header without Newlines - NoNewlineHeader.rats
//-------------------------------------------------------------------------

where:
   'where' w '[\\' w where_binding (w ',' w where_binding)* w '\\]' (w '{' w where_constraint_list w '}')?
 / 'where' w '{' w where_constraint_list w '}';

where_binding:
   'nat' w id_or_op_name
 / 'int' w id_or_op_name
 / 'bool' w id_or_op_name
 / 'unit' w id_or_op_name
 / id_or_op_name;

static_params:
   '[\\' w static_param (w ',' w static_param)* '\\]';

static_param:
   'nat' w id_or_op_name
 / 'int' w id_or_op_name
 / 'bool' w id_or_op_name
 / 'dim' w id_or_op_name
 / 'unit' w id_or_op_name (w ':' w no_new_line_type)? (w 'absorbs' w 'unit')?
 /  'opr' w op
 / id_or_op_name(w 'absorbs' w 'unit')?; 

where_constraint_list:
   where_constraint (w ',' w where_constraint)*;

where_constraint:
   id_or_op_name
 / type w 'coerces' w type
 / type w 'widens' w type
 / unit_constraint
 / int_expr w '<=' w int_expr                         // here begins the definition of a int_constraint
 / int_expr w '<' w int_expr
 / int_expr w '>=' w int_expr
 / int_expr w '>' w int_expr
 / int_expr w '=' w int_expr                         // here ends the definition of a int_constraint
 / bool_expr
 / type w 'widens' w 'or' w 'coerces' w type;

unit_constraint:
   'dimensionless' w '=' w id_or_op_name
 / id_or_op_name w '=' w 'dimensionless';

int_val:
   int_literal_expr
 / qualified_name;

int_expr:
   sum_expr (w '+' w sum_expr / w '-' w sum_expr)*;

sum_expr:
   mul_expr ((w '.' w / sr) mul_expr)*;

mul_expr:
   int_base '^' int_val
 / int_base;

int_base:
   int_val
 / '(' w int_expr w ')';

bool_expr:
   op_bool;

op_bool:
   bool_primary
 / bool_prefix;

bool_primary:
   bool_primary_front bool_prefix
 / bool_primary_front wr bool_primary
 / bool_primary_front wr op wr op_bool
 / bool_primary_front;

bool_prefix:
   op op_bool
 / op wr op_bool;

bool_primary_front:
   'true'
 / 'false'
 / qualified_name
 / '(' w op_bool w ')';

unit_val:
   'dimensionless'
 / qualified_name;

unit_expr:
   mul_div_unit ( (w '.' w / sr) mul_div_unit / ('/' / 'per') mul_div_unit )*;

mul_div_unit:
   unit_base '^' unit_val
 / unit_base;

unit_base:
   unit_val
 / '(' w unit_expr w ')';

requires:
   'requires' w '{' (w expr_list)? '}';

ensures:
   'ensures' w '{' (w expr (w 'provided' w expr)? (w ',' w expr (w 'provided' w expr)?)*)? w '}';

invariant:
   'invariant' w '{' (w expr_list)? w '}';

static_args:
   '[\\' w static_arg_list w '\\]';

static_arg_list:
   static_arg (w ',' w static_arg)*;

static_arg:
   op &(w ',' / w '\\]')
 / !(qualified_name (w 
                       ('\\]' / ']' / ',' / '[\\' / '[' / '->' / 'OR' / 'AND' / 'IMPLIES' / '=')
                    )
                     / 'Unity' / 'dimensionless' / 'true' / 'false'
     ) int_expr
 / !(qualified_name (w 
                       ('\\]' / ']' / ',' / '[\\' / '[' / '->')
                    ) 
                    / 'Unity' / 'dimensionless'
     ) bool_expr
 / 'true'
 / 'false'
 / !(qualified_name (w ('.' / '/' / 'per' / dim_postfix_op)) / 'dimensionless') type
 / unit_expr;

//-------------------------------------------------------------------------
//  Parameters - Parameter.rats
//-------------------------------------------------------------------------

val_param:
   bind_id
 / '(' (w params)? w ')';

abs_val_param:
   '(' (w abs_params)? w ')'
 / type;

parameter:
   keyword
 / var_args
 / param;

params:
   parameter (w ',' w parameter)*;

abs_parameter:
   keyword
 / var_args
 / abs_param;

abs_params:
   abs_parameter (w ',' w abs_parameter)*;

var_args:
   bind_id w ':' w type '...';

keyword:
   param w '=' w expr;

param:
   plain_param;

plain_param:
   bind_id;

abs_param:
   abs_plain_param;

abs_plain_param:
   bind_id w ':' w type
 / type;

single_op_PARAM:
   op
 / '^'
 / encloser
 / 'SUM'
 / 'PROD';

op_header_front:
   'opr' (w 'BIG')? w (left_encloser w '|->' / left_encloser / encloser) (w static_params)? (w params)? w (right_encloser / encloser)
 / 'opr' w val_param w (op / exponent_op / '^') (w static_params)?
 / 'opr' (w 'BIG')? w single_op_PARAM (w static_params)? w val_param;

abs_op_header_front:
   'opr' (w 'BIG')? w (left_encloser w '|->' / left_encloser / encloser) (w static_params)? (w abs_params)? w (right_encloser / encloser)
 / 'opr' w abs_val_param w (op / exponent_op / '^') (w static_params)?
 / 'opr' (w 'BIG')? w single_op_PARAM (w static_params)? w abs_val_param;

//-------------------------------------------------------------------------
//  Method Declaration - Method.rats
//-------------------------------------------------------------------------

md_header_front:
   named_md_header_front
 / method_op_header_front;

abs_md_header_front:
   abs_named_md_header_front
 / method_abs_op_header_front;

named_md_header_front:
   id (w static_params)? w method_val_param;

abs_named_md_header_front:
   id (w static_params)? w method_abs_val_param;

//-------------------------------------------------------------------------
//  Method Parameters - MethodParam.rats
//-------------------------------------------------------------------------

method_val_param:
   '(' (w method_params)? w ')';

method_abs_val_param:
   '(' (w method_abs_params)? w ')';

method_parameter:
   method_keyword
 / var_args
 / method_param;

method_params:
   method_parameter (w ',' w method_parameter)*;

method_abs_parameter:
   method_keyword
 / var_args
 / method_abs_param;

method_abs_params:
   method_abs_parameter (w ',' w method_abs_parameter)*;

method_keyword:
   method_param w '=' w expr;

method_param:
   plain_param
 / 'self';

method_abs_param:
   'self'
 / abs_plain_param;

method_op_header_front:
   'opr' (w 'BIG')? w (left_encloser w '|->' / left_encloser / encloser) (w static_params)?
            (w method_params)? w (right_encloser / encloser) (w ':=' w '(' w subscript_assign_param w ')')?
 / 'opr' w method_val_param w (op / exponent_op / '^') (w static_params)?
 / 'opr' (w 'BIG')? w single_op_PARAM (w static_params)? w method_val_param;

method_abs_op_header_front:
   'opr' (w 'BIG')? w (left_encloser w '|->' / left_encloser / encloser) (w static_params)?
         (w method_abs_params)? w (right_encloser / encloser) (w ':=' w '(' w abs_subscript_assign_param w ')')?
 / 'opr' w method_abs_val_param w (op / exponent_op / '^') (w static_params)?
 / 'opr' (w 'BIG')? w single_op_PARAM (w static_params)? w method_abs_val_param;

subscript_assign_param:
   var_args
 / method_param;

abs_subscript_assign_param:
   var_args
 / method_abs_param;
   

//-------------------------------------------------------------------------
//  Expressions - Expression.rats
//-------------------------------------------------------------------------

Expr: expr; // this is for the names used in the Fortress definition of syntax.

expr:
   expr_front (w expr_tail)*;
//param_local w (':=' / '+=') w int_literal_expr / id / literal_expr;

expr_front:
   assign_expr
 / op_expr
 / delimited_expr
 / flow_expr
 / 'fn' w bind_id w '=>' w expr
 / 'fn' w '(' (w params)? w ')' (w ':' w type)? w '=>' w expr;

expr_tail:
   'typed' w type
 / 'asif' w type;

assign_expr:
   assign_lefts w assign_op w expr;

assign_lefts:
   '(' w assign_left (w ',' w assign_left)* w ')'
 / assign_left;

assign_left:
   primary_front assing_left_tail+
 / qualified_name;

assing_left_tail:
   subscript_assign
 / field_selection_assign;

subscript_assign:
   left_encloser (w static_args)? (w expr_list)? w right_encloser;

field_selection_assign:
   '.' id;

op_expr:
   op_expr_no_enc
 / op_expr_left_encloser
 / encloser;

op_expr_no_enc:
   op_expr_primary
 / op_expr_prefix
 / op;

tight_infix_right:
   encloser op_expr_primary
 / encloser op_expr_prefix
 / encloser wr op_expr_primary
 / encloser wr loose_infix_EXPR
 / encloser wr left_loose_infix
 / encloser;

left_loose_infix:
   op_expr_left_encloser
 / encloser wr op_expr_primary
 / encloser wr op_expr_prefix
 / encloser wr op_expr_left_encloser;

op_expr_left_encloser:
   encloser op_expr_no_enc;

op_expr_primary:
   primary tight_infix_postfix_EXPR
 / primary tight_infix_right
 / primary wr op_expr_primary
 / primary wr loose_infix_EXPR
 / primary wr left_loose_infix
 / primary;

op_expr_prefix:
   op op_expr_primary
 / op op_expr_prefix
 / op op_expr_left_encloser
 / op wr op_expr_primary
 / op wr op_expr_prefix
 / op wr op_expr_left_encloser;

tight_infix_postfix_EXPR:
   op op_expr_primary
 / op op_expr_prefix
 / op op_expr_left_encloser
 / op wr op_expr_primary
 / op wr op_expr_prefix
 / op wr op_expr_left_encloser
 / op;

loose_infix_EXPR:
   op wr op_expr_primary
 / op wr op_expr_prefix
 / op wr op_expr_left_encloser;

primary:
   primary_item (w ',' w primary_item)+ &(encloser (wr / br / w ',' / w right_encloser))
 / primary_item;

primary_item:
   left_associated_primary
 / math_primary;

left_associated_primary:
   dotted_id_chain w static_args parenthesis_delimited parenthesis_delimited_left* selector*
 / dotted_id_chain subscripting_left+ parenthesis_delimited_left* selector*
 / dotted_id_chain parenthesis_delimited parenthesis_delimited_left* selector*
 / dotted_id_chain selector*
 / primary_front subscripting_left* parenthesis_delimited_left* selector+;

dotted_id_chain:
   id ('.' w id)+;

math_primary:
   primary_front math_item*;

primary_front:
   array_expr
 / map_expr
 / comprehension
 / left_encloser (w static_args)? (w expr_list)? w right_encloser
 / parenthesis_delimited
 / literal_expr
 / var_or_fn_ref
 / 'self';

var_or_fn_ref:
   id (w static_args)?;

subscripting_left:
   '{' (w static_args)? (w expr_list)? w '}'
 / '[' (w static_args)? (w expr_list)? w ']'
 / left_encloser (w static_args)? (w expr_list)? w right_encloser;

parenthesis_delimited_left:
   parenthesis_delimited;

parenthesis_delimited:
   parenthesized
 / arg_expr
 / '(' w ')';

selector:
   method_invocation_selector
 / field_selection_selector;

method_invocation_selector:
   '.' w id (w static_args)? parenthesis_delimited parenthesis_delimited_left*;

field_selection_selector:
   '.' w id subscripting_left* parenthesis_delimited_left*;

math_item:
   subscripting
 / exponentiation_EXPR
 / parenthesis_delimited
 / literal_expr
 / var_or_fn_ref
 / 'self';

// There are two different definitions of exponentiation in specification and in Rats! files
exponentiation_EXPR:
   '^' exponent
 / exponent_op;

exponent:
   parenthesis_delimited
 / literal_expr
 / id
 / 'self';

flow_expr:
   'exit' (w id)? (w 'with' w expr)?
 / accumulator (w static_args)? (w '[' generator_clause_list w ']')? w expr
 / 'BIG' w left_encloser w '|->' (w static_args)? w right_encloser w expr
 / 'BIG' w left_encloser w (w static_args)? w right_encloser w expr
 / 'atomic' w atomic_back
 / 'tryatomic' w atomic_back
 / 'spawn' w expr
 / 'throw' w expr;

atomic_back:
   assign_expr
 / op_expr
 / delimited_expr;

generator_clause_list:
   generator_binding (w ',' w generator_clause)*;

generator_binding:
   bind_id_or_bind_tuple w '<-' w expr;

generator_clause:
   generator_binding
 / expr; 

subscripting:
   '[' (w static_args)? (w expr_list)? w ']'
 / '{' (w static_args)? (w expr_list)? w '}'
 / left_encloser (w static_args)? (w expr_list)? w right_encloser;

//-------------------------------------------------------------------------
//  Expressions Enclosed by Keywords or Symbols - DelimitedExpr.rats
//-------------------------------------------------------------------------

delimited_expr locals[String n1, String n2]:
   arg_expr
 / parenthesized
 / do
 / 'label' w n1=id w block_elems w 'end' w n2=id {? n1 == n2}
 / 'while' w generator_clause w do
 / 'for' w generator_clause_list w do_front w 'end'
 / 'if' w generator_clause w 'then' w block_elems (w elifs)? (w else)? w 'end'
 / '(' w 'if' wr generator_clause w 'then' wr block_elems (w elifs)? w else (w 'end')? w ')'
 / 'case' w expr (w (encloser / op))? w 'of' w case_clauses (br case_else)? w 'end'
 / 'case' w 'most' w (encloser / op) w 'of' w case_clauses w 'end'
 / 'typecase' w expr w 'of' w type_case_clauses (br case_else)? w 'end'
 / 'try' w block_elems (w catch)? (w 'finally' w block_elems)? w 'end';

do:
   (do_front w 'also' w)* do_front w 'end';

do_front:
   ('at' w expr w)? ('atomic' w)? 'do' (w block_elems)?;

arg_expr:
   '(' w (expr w ',' w)* (expr w '...' w ',' w)? keyword_expr (w ',' w keyword_expr)* w ')'
 / '(' w (expr w ',' w)* expr w '...' w ')'
 / tuple_expr;

tuple_expr:
   '(' w (expr w ',' w)+ expr w ')';

keyword_expr:
   bind_id w '=' w expr;

parenthesized:
   '(' w expr w ')';

elifs:
   elif(w elif)*;

elif:
   'elif' w generator_clause w 'then' w block_elems;

else:
   'else' w block_elems;

case_clauses:
   case_clause (br case_clause)*;

case_else:
   'else' w '=>' w block_elems;

type_case_clauses:
   type_case_clause (br type_case_clause)*;

type_case_clause:
   id w '=>' w block_elems
 / (id w ':' w)? type w '=>' w block_elems;

catch:
   'catch' w bind_id w catch_clauses;

catch_clauses:
   catch_clause (br catch_clause)*;

catch_clause:
   trait_type w '=>' w block_elems;

map_expr:
   left_encloser (w static_args)? w entry_list w right_encloser;

comprehension:
   ('BIG' w)? '[' (w static_args)? w array_comprehension_clause (br array_comprehension_clause)* w 	']'
 / ('BIG' w)? left_encloser (w static_args)? w entry wr '|' wr generator_clause_list w right_encloser
 / ('BIG' w)? left_encloser (w static_args)? w expr wr '|' wr generator_clause_list w right_encloser;

/****
 The operator "|->" should not be in the left-hand sides of map expressions
 and map/array comprehensions.
****/
mapsto_op:
   '|->' !(w expr (w '|->' / wr '|' / w '}' / w ','));

/****
 The operator "<-" should not be in the left-hand sides of
 generator clause lists.
*****/
left_arrow_op:
   '<-' !(w expr (w '<-' / w ','));

entry:
   expr w '|->' w expr;

array_comprehension_left:
   id_or_int w '|->' w expr
 / '(' w id_or_int w ',' w id_or_int_list w ')' w '|->' w expr;

id_or_int:
   id
 / int_literal_expr;

id_or_int_list:
   id_or_int (w ',' w id_or_int)*;

expr_list:
   expr (w ',' w expr)*;

entry_list:
   entry (w ',' w entry)*;

//-------------------------------------------------------------------------
//  Expressions without Newlines - NoNewlineExpr.rats
//-------------------------------------------------------------------------

no_new_line_expr:
   no_new_line_expr_front no_new_line_expr_tail*;

no_new_line_expr_front:
   no_new_line_assign_expr
 / no_new_line_op_expr
 / delimited_expr
 / no_new_line_flow_expr
 / 'fn' w bind_id w '=>' w no_new_line_expr
 / 'fn' w '(' (w params)? w ')' (w ':' w type)? w '=>' w no_new_line_expr;

no_new_line_expr_tail:
   s 'typed' w no_new_line_type
 / s 'asif' w no_new_line_type;

no_new_line_assign_expr:
   assign_lefts s assign_op w no_new_line_expr;

no_new_line_op_expr:
   no_new_line_op_expr_no_enc
 / no_new_line_op_expr_left_encloser
 / encloser;

no_new_line_op_expr_no_enc:
   no_new_line_op_expr_primary
 / no_new_line_op_expr_prefix
 / op;

no_new_line_tight_infix_right:
   encloser no_new_line_op_expr_primary
 / encloser no_new_line_op_expr_prefix
 / encloser sr no_new_line_op_expr_primary
 / encloser sr no_new_line_loose_infix_EXPR
 / encloser sr no_new_line_left_loose_infix
 / encloser;

no_new_line_left_loose_infix:
   no_new_line_op_expr_left_encloser
 / encloser sr no_new_line_op_expr_primary
 / encloser sr no_new_line_op_expr_prefix
 / encloser sr no_new_line_op_expr_left_encloser;

no_new_line_op_expr_left_encloser:
   encloser no_new_line_op_expr_no_enc;

no_new_line_op_expr_primary:
   primary no_new_line_tight_infix_postfix_EXPR
 / primary no_new_line_tight_infix_right
 / primary sr no_new_line_op_expr_primary
 / primary sr no_new_line_loose_infix_EXPR
 / primary sr no_new_line_left_loose_infix
 / primary;

no_new_line_op_expr_prefix:
   op no_new_line_op_expr_primary
 / op no_new_line_op_expr_prefix
 / op no_new_line_op_expr_left_encloser
 / op sr no_new_line_op_expr_primary
 / op sr no_new_line_op_expr_prefix
 / op sr no_new_line_op_expr_left_encloser;

no_new_line_tight_infix_postfix_EXPR:
   op no_new_line_op_expr_primary
 / op no_new_line_op_expr_primary
 / op no_new_line_op_expr_left_encloser
 / op sr no_new_line_op_expr_primary
 / op sr no_new_line_op_expr_prefix
 / op sr no_new_line_op_expr_left_encloser
 / op;

no_new_line_loose_infix_EXPR:
   op wr no_new_line_op_expr_primary
 / op wr no_new_line_op_expr_prefix
 / op sr no_new_line_op_expr_left_encloser;

no_new_line_generator_binding:
   bind_id_or_bind_tuple w '<-' w no_new_line_expr;

no_new_line_generator_clause:
   no_new_line_generator_binding
 / no_new_line_expr; 

no_new_line_flow_expr:
   'exit' (w id)? (w 'with' w no_new_line_expr)?
 / accumulator (w static_args)? (w '[' generator_clause_list w ']')? w no_new_line_expr
 / 'BIG' left_encloser w '|->' (w static_args)? w right_encloser w no_new_line_expr
 / 'BIG' left_encloser w (w static_args)? w right_encloser w no_new_line_expr
 / 'atomic' w no_new_line_atomic_back
 / 'tryatomic' w no_new_line_atomic_back
 / 'spawn' w no_new_line_expr
 / 'throw' w no_new_line_expr;

no_new_line_atomic_back:
   assign_expr
 / no_new_line_op_expr
 / delimited_expr;

no_new_line_generator_clause_list:
   generator_binding (s ',' w no_new_line_generator_clause)*;

no_new_line_var_w_types:
   no_new_line_var_w_type
 / '(' w no_new_line_var_w_type (w ',' w no_new_line_var_w_type)+ w ')';

no_new_line_var_w_type:
   bind_id s no_new_line_is_type;

no_new_line_is_type:
   ':' w no_new_line_type;

no_new_line_is_type_or_none:
   ':' w no_new_line_type_or_none;

no_new_line_type_or_none:
   no_new_line_type
 / 'None';

//-------------------------------------------------------------------------
//  Expressions within Array Expressions - NoSpaceExpr.rats
//-------------------------------------------------------------------------

no_space_expr:
   no_space_expr_front;

no_space_expr_front:
   no_space_assign_expr
 / no_space_op_expr
 / delimited_expr;

no_space_assign_expr:
   assign_lefts w assign_op w no_space_expr;

no_space_op_expr:
   no_space_op_expr_no_enc
 / no_space_op_expr_left_encloser
 / encloser;

no_space_op_expr_no_enc:
   no_space_op_expr_primary
 / no_space_op_expr_prefix
 / op;

no_space_tight_infix_right:
   encloser no_space_op_expr_primary
 / encloser no_space_op_expr_prefix
 / encloser;

no_space_op_expr_left_encloser:
   encloser no_space_op_expr_no_enc;

no_space_op_expr_primary:
   primary no_space_tight_infix_postfix
 / primary no_space_tight_infix_right
 / primary;

no_space_op_expr_prefix:
   op no_space_op_expr_primary
 / op no_space_op_expr_prefix
 / op no_space_op_expr_left_encloser;

no_space_tight_infix_postfix:
   op no_space_op_expr_primary
 / op no_space_op_expr_prefix
 / op no_space_op_expr_left_encloser
 / op;

//-------------------------------------------------------------------------
//  Local Declarations - LocalDecl.rats
//-------------------------------------------------------------------------

block_elems: // Inserir catch_clause na definição, pois acredito que faltava
   block_elem br block_elems
 / block_elem w ';' &(w 'elif' / w 'also' / w 'end' / w 'catch' / w 'forbid' / w 'finally' / w ')')
 / block_elem &(w 'elif' / w 'also' / w 'end' / w 'catch' / w 'forbid' / w 'finally' / w ')')
 / block_elem &(w else / br catch_clause / br case_clause / br (id w ':' w)? type / br case_else)
 / block_elem w ';' &(w else);

block_elem:
  no_new_line_expr (s ',' w no_new_line_generator_clause_list)?;

val_param_local:
   '(' (w params_local)? w ')'
 / bind_id;

params_local:
   (param_local w ',' w)* (var_args_local w ',' w)? keyword_local (w ',' w keyword_local)*
 / (param_local w ',' w)* var_args_local
 / param_local (w ',' w param_local)*;

param_local:
   bind_id s ':' s no_new_line_type
 / bind_id; 

var_args_local:
   bind_id s ':' s no_new_line_type '...';

keyword_local:
   param_local s '=' w no_new_line_expr;

local_var_decl:
   ('var' w)? local_var_may_types s '=' w no_new_line_expr
 / ('var' w)? no_new_line_var_w_type_or_patterns s ':=' w no_new_line_expr
 / ('var' w)? no_new_line_var_w_types
 / var_wo_types s '=' w no_new_line_expr
 / ('var' w)? var_wo_types s ':' s no_new_line_type s '...'
 / ('var' w)? var_wo_types s ':' s tuple_type s '...';

local_var_may_types:
   local_var_may_type
 / '(' w local_var_may_type (w ',' w local_var_may_type)+ w ')';

local_var_may_type:
   bind_id (s ':' s no_new_line_type)?;

var_wo_types:
   var_wo_type
 / '(' w var_wo_type (w ',' w var_wo_type)+ w ')';

var_wo_type:
   bind_id
 / unpasting;

no_new_line_var_w_type_or_patterns:
   no_new_line_var_w_type_or_pattern
 / '(' w no_new_line_var_w_type_or_pattern (w ',' w no_new_line_var_w_type_or_pattern)+ w ')';

no_new_line_var_w_type_or_pattern:
   bind_id s no_new_line_is_type_or_pattern;

no_new_line_is_type_or_pattern:
   ':' s no_new_line_type;

unpasting:
   '[' w unpasting_elems w ']';

unpasting_elems:
   unpasting_elem (rect_separator unpasting_elem)*;

unpasting_elem:
   bind_id ('[' w unpasting_dim w ']')?
 / unpasting;

unpasting_dim:
   extent_range ( w 'BY' w extent_range)+;

case_clause:
   no_new_line_expr w '=>' w block_elems;

//-------------------------------------------------------------------------
//  Literals - Literal.rats and NoSpaceLiteral.rats
//-------------------------------------------------------------------------

array_expr:
   '[' (w static_args)? w no_space_expr multi_dim_cons* w ']';

multi_dim_cons:
   rect_separator no_space_expr;

literal_expr:
   '(' w ')'
 / numeric_literal_expr
 / char_literal_expr
 / string_literal_expr;

escape_sequence:
   '\\' ('b' / 't' / 'n' / 'f' / 'r' / '"' / '\\')
 / '\\u' [0-9A-Z] [0-9A-Z] [0-9A-Z] [0-9A-Z]
 / '\\u' [0-9a-f] [0-9a-f] [0-9a-f] [0-9a-f];

numeric_literal_expr:    // there is some differences in Rats! specification about numeric_literal
   float_literal_expr
 / int_literal_expr;

float_literal_expr:
   digit_string '.' digit_string;

int_literal_expr:
   digit_string;

digit_string:
   [0-9]+;

char_literal_expr:
   '\'' char_literal_content '\'';

string_literal_expr:
   '\"' string_literal_content* '\"';

string_literal_content:
   escape_sequence
 / !('\"' / '\\') .;

char_literal_content:
   escape_sequence
 / !('\'' / '\\') .;

//-------------------------------------------------------------------------
//  Types - Type.rats
//-------------------------------------------------------------------------

type:
   !'1' ('io' w)? type_primary (w 'in' w expr)?;

op_type:
   type_primary 
 / type_prefix;

type_primary:
   type_primary_front tight_infix_postfix
 / type_primary_front wr type_primary
 / type_primary_front wr loose_infix
 / type_primary_front;

type_prefix:
   dim_prefix_op type_primary
 / dim_prefix_op type_prefix
 / dim_prefix_op wr type_primary
 / dim_prefix_op wr type_prefix;

tight_infix_postfix:
   '->' type_primary
 / '->' type_prefix
 / dim_infix_op type_primary
 / dim_infix_op type_prefix
 / dim_postfix_op wr type_primary
 / dim_postfix_op wr type_prefix
 / dim_postfix_op;

loose_infix:
   '->' wr type_primary
 / '->' wr type_prefix
 / dim_infix_op wr type_primary
 / dim_infix_op wr type_prefix;

type_infix_op:
   '->';

dim_infix_op:
   'DOT'
 / '/'
 / 'per';

type_primary_front:
   type_front type_tail*; // na definição não exige espaço. Achei estranho!

type_front:
   parenthesized_type
 / domain
 / tuple_type
 / type_ref
 / void_type
 / '1';

parenthesized_type:
   '(' w type w ')';

domain:
   '(' w (type w ',' w)* (type w '...' w ',' w)? keyword_type (w ',' w keyword_type)* w ')'
 / '(' w (type w ',' w)* type w '...' w ')';

keyword_type:
   bind_id w '=' w type;

tuple_type:
   '(' w type w ',' w type_list w ')';

type_list:
   type (w ',' w type)*;

type_ref:
   'Unity'
 / id static_args?;

void_type:
   '(' w ')';

type_tail:
   array_type_size
 / exponentiation
 / parenthesized_type_left
 / id_left;

array_type_size:
   '[' (w array_size)? w ']';

array_size:
   extent_range (w ',' w extent_range)*;

extent_range:
   (static_args w)? '#' (w static_args)?
 / (static_args w)? ':' (w static_args)?
 / static_args;

exponentiation:
   '^' int_expr
 / '^' '(' w extent_range (w 'BY' w extent_range)* w ')';

parenthesized_type_left:
   '(' w op_type w ')';

id_left:
   id;

dim_prefix_op:
   'square'
 / 'cubic'
 / 'inverse';

dim_postfix_op:
   'squared'
 / 'cubed';

trait_type:
   trait_type_front trait_type_tail+
 / type_ref;

trait_type_front:
   parenthesized_type
 / tuple_type
 / type_ref
 / void_type;

trait_type_tail:
   array_type_size_trait
 / exponentiation_trait;

array_type_size_trait:
   '[' (w array_size)? w ']';

exponentiation_trait:
   '^' int_expr
 / '^' '(' w extent_range (w 'BY' w extent_range)* w ')'; 

//-------------------------------------------------------------------------
//  Types without Newlines - NoNewlineType.rats
//-------------------------------------------------------------------------

no_new_line_type:
   !'1' no_new_line_type_primary (w 'in' w no_new_line_expr)?;

no_new_line_type_list:
   no_new_line_type (w ',' w no_new_line_type)*;

no_new_line_tuple_type:
   '(' w no_new_line_type w ',' w no_new_line_type_list w ')';

no_new_line_type_primary:
   type_primary_front no_new_line_tight_infix_postfix
 / type_primary_front sr no_new_line_type_primary
 / type_primary_front sr no_new_line_loose_infix
 / type_primary_front;

no_new_line_type_prefix:
   dim_prefix_op no_new_line_type_primary
 / dim_prefix_op no_new_line_type_prefix
 / dim_prefix_op sr no_new_line_type_primary
 / dim_prefix_op sr no_new_line_type_prefix;

no_new_line_tight_infix_postfix:
   type_infix_op no_new_line_type_primary
 / type_infix_op no_new_line_type_prefix
 / dim_infix_op no_new_line_type_primary
 / dim_infix_op no_new_line_type_prefix
 / dim_postfix_op sr no_new_line_type_primary
 / dim_postfix_op sr no_new_line_type_prefix
 / dim_postfix_op;

no_new_line_loose_infix:
   type_infix_op sr no_new_line_type_primary
 / type_infix_op sr no_new_line_type_prefix
 / dim_infix_op sr no_new_line_type_primary
 / dim_infix_op sr no_new_line_type_prefix;

//-------------------------------------------------------------------------
//  Symbols and Operators - Symbol.rats
//-------------------------------------------------------------------------

encloser_pair:
   (left_encloser / encloser) (w '.' w)? (right_encloser / encloser);

bar:
   &('|' wr generator_clause_list closing_comprehension) '|';

closing_comprehension:       // In Rats! definiton, a right encloser is a closing comprehension too
   w '}'
 / w '|>'
 / br array_comprehension_clause
 / w ']';

sd:
   ('*' / '.')?;

bars:
   '|' (sd '|')*;

slashes:
   '/' (sd '/')*
 / '\\' (sd '\\')*;

lesses:
   '<' (sd '<')*;

greaters:
   '>' (sd '>')*;

encloser:
   !bar bars !('*' / '.' / '>' / '/' / '\\' / '->');

left_encloser:
   left_encloser_multi
 / '{' / '[';
// / !('|') .;        // I igonre this because the implementation in Rats! use auxiliar functions to check if is a valid left encloser

left_encloser_multi:
   '(.' ('/'+ / '\\'+)
 / '[/\\/\\/'
 / '[/\\/'
 / '[' (sd slashes)
 / '{' (sd slashes)
 / lesses sd (slashes / bars)
 / bars sd slashes
 / '{*'
 / '[*'
 / '((.>'
 / '(.<';

right_encloser:
   right_encloser_multi
 / '}' / ']';
// / !('|') .;      // I igonre this because the implementation in Rats! use auxiliar functions to check if is a valid right encloser

right_encloser_multi:
   '/'+ '.)'
 / '\\'+ '.)'
 / slashes sd (greaters / bars / ']' / '}')
 / bars sd greaters
 / '*]'
 / '*}'
 / ']'
 / '}'
 / '>.)'
 / '<.))'
 / '/\\/\\/]'
 / '/\\/]';

exponent_op:
   '^T'
 / '^' (encloser / not_comp_op);

//----------------------------------------------------------------
// An operator name has at least two different uppercase letters
// also it does not begin and end with an underscore
//----------------------------------------------------------------
op_name:
   !('SUM' / 'PROD' / 'BY') head_op_name
 / keyword_operator;

head_op_name locals[String ch1, String ch2]:
   ch1=[A-Z] (
        '_'* ch2=[A-Z] !({?ch1 == ch2}) tail_op_name
      / '_'* &[A-Z] head_op_name
     );     

tail_op_name:
   !([A-Za-z0-9] / '_')       // there is no more symbols
 / ('_'* [A-Z])+ !([A-Za-z0-9] / '_');                                                         

op:
   cond_op
 / not_comp_op !'='
 / comp_op;

comp_op:
   '==='
 / '=/='
 / '<='
 / '<'         // i put this
 / '>='
 / '>';        // i put this

cond_op:
   ':' (encloser / not_comp_op) ':'
 / (encloser / not_comp_op) ':';

multi_op:
   '-/->'
 / '<-/-'
 / '-->'
 / '==>'
 / '>>>'
 / mapsto_op
 / '<<<'
 / '<->'
 / left_arrow_op
 / '<=>'
 / '->'
 / double_right_arrow
 / '>>'
 / '<<'
 / '**'
 / '!!'
 / '::'
 / !right_encloser_multi '///'
 / !right_encloser_multi '//';

// The definition in Rats! uses a function the test if the character read is a valid operator
// The op_expr was failured because a single_op could be anything. Then, i changed this for the usually operators.
single_op:
//   !(encloser / left_encloser / right_encloser / multi_op / comp_op / '=>') . !'*';
   !(encloser / left_encloser / right_encloser / multi_op / comp_op / '=>')
        ('+' / '*' / '-' / '/' / '%') !'*';

not_comp_op:
   op_name
 / multi_op
 / single_op;

compound_op:
   not_comp_op '=';

/* The operator "=>" should not be in the left-hand sides of case/typecase expressions. */
double_right_arrow:
   '=>' &(w block_elems w '=>');

/* The operator "BY" should not be used with ExtentRange. */
cross_op:
   'BY' &(w extent_range);

less_than_equal:
   '<=' / 'LE';

less_than:
   '<' / 'LT';

greater_than_equal:
   '>=' / 'GE';

greater_than:
   '>' / 'GT';

implies:
   '->' / 'IMPLIES';

assign_op:
   ':='
 / compound_op;

accumulator:
   'SUM'
 / 'PROD'
 / 'BIG' w (encloser / op);

array_comprehension_clause:
   array_comprehension_left wr bar wr generator_clause_list;

//-------------------------------------------------------------------------
//  Identifiers - Identifier.rats
//-------------------------------------------------------------------------

Id: id; // this is for compatibility with the Fortress names used in the api grammars

id_or_op_name:
   id
 / op_name;

id:
   !(keywords / op_name) (id_start id_rest+ / unicode_id_start) ;  // It can not be '_'

id_start:
   unicode_id_start / '_';

id_rest:
   '_' / '\'' / unicode_id_rest;

bind_id:
   id / '_'; 

bind_id_list:
   bind_id (w ',' w bind_id)*;

bind_id_or_bind_tuple:
   bind_id
 / '(' w bind_id w ',' w bind_id_list w ')';

simple_name:
   id
 / 'opr' w op
 / 'opr' w encloser_pair;

api_name:
   qualified_name;

qualified_name:
   id &(w '...')                // it ignores the dots
 / id ('.' id)* &(w '...')       // it ignores the dots
 / id ('.' id)*;

//-------------------------------------------------------------------------
//  Unicode.rats
//-------------------------------------------------------------------------

unicode_id_start:  // In the original rats file definition, this nonterminal allow the set of unicode characters
   [a-zA-Z];

unicode_id_rest:
   [a-zA-Z0-9];

//-------------------------------------------------------------------------
//  Keywords - Keyword.rats
//-------------------------------------------------------------------------

keywords:
   key !id_rest;

key:
   'absorbs'
 / 'abstract'
 / 'also'
 / 'api'
 / 'asif'
 / 'as'
 / 'atomic'
 / 'at'
 / 'bool'
 / 'case'
 / 'catch'
 / 'coerce'
 / 'coerces'
 / 'component'
 / 'comprises'
 / 'default'
 / 'dim'
 / 'do'
 / 'elif'
 / 'else'
 / 'end'
 / 'ensures'
 / 'except'
 / 'excludes'
 / 'exit'
 / 'export'
 / 'extends'
 / 'finally'
 / 'fn'
 / 'forbid'
 / 'for'
 / 'from'
 / 'getter'
 / 'hidden'
 / 'if'
 / 'import'
 / 'int'
 / 'invariant'
 / 'io'
 / 'juxtaposition'
 / 'label'
 / 'most'
 / 'native'
 / 'nat'
 / 'object'
 / 'of'
 / 'opr'
 / 'or'
 / 'override'
 / 'private'
 / 'property'
 / 'provided'
 / 'requires'
 / 'self'
 / 'settable'
 / 'setter'
 / 'spawn'
 / 'syntax'
 / 'test'
 / 'then'
 / 'throws'
 / 'throw'
 / 'trait'
 / 'transient'
 / 'tryatomic'
 / 'try'
 / 'typecase'
 / 'type'
 / 'unit'
 / 'value'
 / 'var'
 / 'where'
 / 'while'
 / 'widens'
 / 'with'
 / 'wrapped'
 / 'goto'
 / 'idiom'
 / 'public'
 / 'pure'
 / 'reciprocal'
 / 'static';

keyword_operator:
   key_op !id_rest;

key_op:
   'juxtaposition'
 / 'in'
 / 'per'
 / 'square'
 / 'cubic'
 / 'inverse'
 / 'squared'
 / 'cubed'
 / 'BIG'
 / 'FORALL'
 / 'SI_init';
 
 // There are more other keywords

//-------------------------------------------------------------------------
//  Spaces and Comments - Spacing.rats
//-------------------------------------------------------------------------

end_of_file:
   !.;

white_space:
   space / new_line;

space:
   ' '
 / '\f'
 / no_new_line_comment;

new_line:
   '\r\n'
 / '\r'
 / '\n'
 / comment;

no_new_line_comment:
   '(*' no_new_line_comment_content* '*)';

no_new_line_comment_content:
   no_new_line_comment
 / '*' !')'
 / !'*' !new_line .;

comment:                        // it comment may have new lines.
   '(*' comment_content* '*)';

comment_content:
   comment 
 / '*' !')'
 / !'*' .; 

w:
   white_space*;
  
wr:
   white_space+;

s:
   space*;
   
sr:
   space+;

nl:
   s new_line w;

br:
   nl / s ';' w;

rect_separator:
   (w ';')+ w
 / sr
 / nl;

//-------------------------------------------------------------------------
// Extensibility - Syntax.rats
//-------------------------------------------------------------------------

grammar_def[Map map] returns[String name, String r] locals[String n, String r1, List l, List l1]:
   'native' w 'grammar' w name=id &(collect_nonterminal_decl<l>) {r = '';}
     (br nonterminal_decl<n> {r = concat(r, concat(n, ' : {?false};\n'));})* w 'end'
 / 'grammar' w name=id (w grammar_extends<map>)? &(collect_nonterminal_def<l>) {l1 = availableNonterminals(map, l);}
     {r = '';} (br nonterminal_def<l1,r1> {r = concat(r, concat(r1, '\n'));})* w 'end';

grammar_extends[Map map]:
   'extends' w qualified_names<map>;

qualified_names[Map map] locals[String n, boolean b]:
   n=qualified_name {? true == checkGrammarName(map, n)}
 / '{' n=qualified_name {? true == checkGrammarName(map, n) }
      (w ',' w n=qualified_name {? true == checkGrammarName(map, n) })* '}';

nonterminal_def[List l] returns[String r] locals[String n, String r1]:
   n=id w '|' w ':=' w syntax_extension_def<l, r1> {r = concat(n,concat(' : ', r1));}
         (w syntax_extension_def_or<l,r1> {r = concat(r, concat(' / ', r1));})* {r = concat(r, ';');}
 / nonterminal_header<n> w ':' (w trait_type)? w ':=' w syntax_def<l,r1> {r = concat(n, concat(' : ', r1));}
         (w syntax_def_or<l,r1> {r = concat(r, concat(' / ', r1));})* {r = concat(r, ';');}
 / nonterminal_decl<n> {r = concat(n, ' : {?false};');};

nonterminal_decl returns[Strng name]:
   nonterminal_header<name> w ':' w trait_type;

nonterminal_header returns[String name]:
   ('private' w)? name=id (w syntax_params)? (w static_params)? (':' type)? (w where)?;

syntax_params:
   '(' w syntax_param (w ',' w syntax_param)* w ')';

syntax_param:
   id ':' trait_type;

syntax_def[List l] returns[String r]:
   (choice_modifier w)? syntax_symbols<l,r> w '=>' w pre_transformer_decl;

syntax_extension_def[List l] returns[String r]:
    syntax_def<l,r>
  / (super_choice_modifier w)? id w 'from' w id;

syntax_def_or[List l] returns[String r]:
   '|' w syntax_def<l,r>;

syntax_extension_def_or[List l] returns[String r]:
   '|' w syntax_extension_def<l,r>;

choice_modifier:
   'private';

super_choice_modifier:
   'private'
 / 'without';

pre_transformer_decl:
   pre_transformer;

pre_transformer:
   'case' w id w 'of' w case_transformer_clauses w 'end'
 / (id w )? '<[' w (']' !'>' / !']' .)* w ']>';   // Na implementação de Fortress o trecho entre '<[' e ']>' é guardado sem checagem com o parser

case_transformer_clauses:
   case_transformer_clause (br case_transformer_clause)*;

case_transformer_clause:
   id (w '(' w bind_id_list w ')')? w '=>' w pre_transformer;

syntax_symbols[List l] returns[String s] locals[String s1]:
   syntax_symbol<l,s> (symbs<l,s1> {s = concatW(s, s1);})* &(w '=>');

syntax_symbols_x[List l] returns[String s] locals[String s1]:
   syntax_symbol<l,s> (symbs<l,s1> {s = concatW(s, s1);})*;

symbs[List l] returns[String s]:
   space_or_breakline+ syntax_symbol<l,s>;

space_or_breakline:
   (' ' / '\f')+
 / ('\r\n' / '\r' / '\n');

syntax_symbol[List l] returns[String s] locals[String s1]:
   'NOT' w symbol_mod<l,s1> {s = concat('!', s1);}
 / 'AND' w symbol_mod<l,s1> {s = concat('&', s1);}
 / symbol_mod<l,s>;

symbol_mod[List l] returns[String s] locals[String s1]:
   single<l,s1> '?' {s = concat(s1, '?');}
 / single<l,s1> '*' {s = concat(s1, '*');}
 / single<l,s1> '+' {s = concat(s1, '+');}
 / single<l,s>;

single[List l] returns[String s]:
   group_symbol<l,s>
 / base_symbol<l,s>;

base_symbol[List l] returns[String s]:
   (id ':')? symbol<l,s>;

group_symbol[List l] returns[String s] locals[String s1]:
   '{' w syntax_symbols_x<l,s1> w '}' {s = concat('(', concat(s1, ')'));};

symbol[List l] returns[String s]:
   item<l,s> '#'?;

item[List l] returns[String s] locals[String ch]:
   '_' {s = '.';}
 / '[' {s = '[';} (character_class<ch> {s = concat(s,ch);})* ']' {s = concat(s, ']');}
 / 'TAB' {s = '\t';}
 / 'FORMFEED' {s = '\f';}
 / 'RETURN' {s = '\r';}
 / 'NEWLINE' {s = 'br';}
 / 'SPACE' {s = 'wr';}
 / 'BACKSPACE' {s = '\u2408';}
 /  !(w '=>') item_text<l,s>;

character_class returns[String ch] locals[String ch1]:
   char<ch> (':' char<ch1> {ch = concat(ch, concat('-', ch1));})?;

char returns[String ch]:
   'TAB' {ch = '\t';}
 / 'FORMFEED' {ch = '\f';}
 / 'RETURN' {ch = '\r';}
 / 'NEWLINE' {ch = '\n';}
 / 'SPACE' {ch = ' ';}
 / 'BACKSPACE' {ch = '\u2408';}
 / utf16<ch>;

// Look if is a nonterminal name or a terminal. A terminal name is all text that if not an available nonterminal name
item_text[List l] returns[String s] locals[String ch]:
   !special_symbols {s= '';} (utf16<ch> {s = concat(s, ch);})+ {s = formatTerminal(l,s);};

utf16 returns[String ch]:
   '`' special_chars {ch='';}           // look this
 / '`' special_symbols {ch='';}         // look this
 / !special_chars ch=.;

special_chars:
   ' '
 / '\f'
 / '\r\n'
 / '\r'
 / '\n'
 / ':'
 / '?'
 / '#'
 / '+'
 / '*'
 / '['
 / ']'
 / '`'
 / '|'
 / '_'
 / '{'
 / '}';

special_symbols:
   'TAB'
 / 'FORMFEED'
 / 'RETURN'
 / 'NEWLINE'
 / 'SPACE'
 / 'BACKSPACE'
 / 'AND'
 / 'NOT'
 / '=>';


// ----------------------------
//  Rules for Catching all Nonterminais Definition
// -----------------------------

collect_nonterminal_decl returns[List l] locals[String n]:
   (br nonterminal_decl<n> {l = addList(l, n);})*;

collect_nonterminal_def returns[List l] locals[List l1]:
  {l1 = newList();} (br nonterminal_name_def<l1, l> {l1 = l;})*;

nonterminal_name_def[List l] returns[List l1] locals[String n, String r]:
   n=id w '|' w ':=' w syntax_extension_def<l,r> (w syntax_extension_def_or<l,r>)* {l1 = l;}
 / nonterminal_header<n> w ':' (w trait_type)? w ':=' w syntax_def<l,r>
         (w syntax_def_or<l,r>)* {l1 = addList(l, n);}
 / nonterminal_decl<n> {l1 = addList(l, n);};
